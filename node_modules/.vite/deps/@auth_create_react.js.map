{
  "version": 3,
  "sources": ["../../@hono/auth-js/src/client.ts", "../../@hono/auth-js/src/react.tsx"],
  "sourcesContent": ["import { AuthError } from '@auth/core/errors'\nimport type { BuiltInProviderType, ProviderType } from '@auth/core/providers'\nimport type { LoggerInstance, Session } from '@auth/core/types'\nimport { useEffect, useState } from 'react'\n\nclass ClientFetchError extends AuthError {}\n\nexport class ClientSessionError extends AuthError {}\n\nexport interface GetSessionParams {\n  event?: 'storage' | 'timer' | 'hidden' | string\n  triggerEvent?: boolean\n}\n\nexport interface AuthClientConfig {\n  baseUrl: string\n  basePath: string\n  credentials: RequestCredentials\n  lastSync: number\n  session: Session | null\n  fetchSession: (params?: GetSessionParams) => Promise<void>\n}\n\nexport interface UseSessionOptions<R extends boolean> {\n  required: R\n  onUnauthenticated?: () => void\n}\n\nexport type LiteralUnion<T extends U, U = string> = T | (U & Record<never, never>)\n\nexport interface ClientSafeProvider {\n  id: LiteralUnion<BuiltInProviderType>\n  name: string\n  type: ProviderType\n  signinUrl: string\n  callbackUrl: string\n}\n\nexport interface SignInOptions extends Record<string, unknown> {\n  callbackUrl?: string\n  redirect?: boolean\n}\n\nexport interface SignInResponse {\n  error: string | undefined\n  status: number\n  ok: boolean\n  url: string | null\n}\n\nexport type SignInAuthorizationParams =\n  | string\n  | string[][]\n  | Record<string, string>\n  | URLSearchParams\n\nexport interface SignOutResponse {\n  url: string\n}\n\nexport interface SignOutParams<R extends boolean = true> {\n  callbackUrl?: string\n  redirect?: R\n}\n\nexport interface SessionProviderProps {\n  children: React.ReactNode\n  session?: Session | null\n  refetchInterval?: number\n  refetchOnWindowFocus?: boolean\n  refetchWhenOffline?: false\n}\n\nexport type UpdateSession = (data?: any) => Promise<Session | null>\n\nexport type SessionContextValue<R extends boolean = false> = R extends true\n  ?\n      | { update: UpdateSession; data: Session; status: 'authenticated' }\n      | { update: UpdateSession; data: null; status: 'loading' }\n  :\n      | { update: UpdateSession; data: Session; status: 'authenticated' }\n      | {\n          update: UpdateSession\n          data: null\n          status: 'unauthenticated' | 'loading'\n        }\n\nexport type WindowProps = {\n  url: string\n  title: string\n  width: number\n  height: number\n}\n\nexport type AuthState = {\n  status: 'loading' | 'success' | 'errored'\n  error?: string\n}\n\nexport async function fetchData<T = any>(\n  path: string,\n  config: {\n    baseUrl: string\n    basePath: string\n    credentials: RequestCredentials\n  },\n  logger: LoggerInstance,\n  req: any = {}\n): Promise<T | null> {\n  const url = `${config.baseUrl}${config.basePath}/${path}`\n  try {\n    const options: RequestInit = {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(req?.headers?.cookie ? { cookie: req.headers.cookie } : {}),\n      },\n      credentials: config.credentials,\n    }\n\n    if (req?.body) {\n      options.body = JSON.stringify(req.body)\n      options.method = 'POST'\n    }\n\n    const res = await fetch(url, options)\n    const data = await res.json()\n    if (!res.ok) {\n      throw data\n    }\n    return data as T\n  } catch (error) {\n    logger.error(new ClientFetchError((error as Error).message, error as any))\n    return null\n  }\n}\n\nexport function useOnline(): boolean {\n  const [isOnline, setIsOnline] = useState(\n    typeof navigator !== 'undefined' ? navigator.onLine : false\n  )\n\n  useEffect(() => {\n    const abortController = new AbortController()\n    const { signal } = abortController\n\n    const setOnline = () => {\n      setIsOnline(true)\n    }\n    const setOffline = () => {\n      setIsOnline(false)\n    }\n\n    window.addEventListener('online', setOnline, { signal })\n    window.addEventListener('offline', setOffline, { signal })\n\n    return () => {\n      abortController.abort()\n    }\n  }, [])\n\n  return isOnline\n}\n\nexport function now(): number {\n  return Math.floor(Date.now() / 1000)\n}\n\ninterface ParsedUrl {\n  origin: string\n  host: string\n  path: string\n  base: string\n  toString: () => string\n}\n\nexport function normalizeBasePath(config: Partial<AuthClientConfig>): Partial<AuthClientConfig> {\n  if (config.basePath && /^https?:\\/\\//.test(config.basePath)) {\n    const url = new URL(config.basePath)\n    return {\n      ...config,\n      baseUrl: url.origin,\n      basePath: url.pathname.replace(/\\/$/, ''),\n    }\n  }\n  return config\n}\n\nexport function parseUrl(url?: string): ParsedUrl {\n  const defaultUrl = 'http://localhost:3000/api/auth'\n  const parsedUrl = new URL(url ? (url.startsWith('http') ? url : `https://${url}`) : defaultUrl)\n  const path = parsedUrl.pathname === '/' ? '/api/auth' : parsedUrl.pathname.replace(/\\/$/, '')\n  const base = `${parsedUrl.origin}${path}`\n\n  return {\n    origin: parsedUrl.origin,\n    host: parsedUrl.host,\n    path,\n    base,\n    toString: () => base,\n  }\n}\n", "import type { BuiltInProviderType, RedirectableProviderType } from '@auth/core/providers'\nimport type { LoggerInstance, Session } from '@auth/core/types'\nimport * as React from 'react'\nimport { useCallback, useContext, useEffect, useMemo, useState } from 'react'\nimport {\n  ClientSessionError,\n  fetchData,\n  normalizeBasePath,\n  now,\n  parseUrl,\n  useOnline,\n} from './client'\nimport type {\n  WindowProps,\n  AuthState,\n  AuthClientConfig,\n  SessionContextValue,\n  SessionProviderProps,\n  GetSessionParams,\n  UseSessionOptions,\n  LiteralUnion,\n  SignInOptions,\n  SignInAuthorizationParams,\n  SignInResponse,\n  ClientSafeProvider,\n  SignOutParams,\n  SignOutResponse,\n} from './client'\n\nconst logger: LoggerInstance = {\n  debug: console.debug,\n  error: console.error,\n  warn: console.warn,\n}\n\nclass AuthConfigManager {\n  private static instance: AuthConfigManager | null = null\n  private config: AuthClientConfig\n\n  private constructor() {\n    this.config = this.createDefaultConfig()\n  }\n\n  private createDefaultConfig(): AuthClientConfig {\n    return {\n      baseUrl: typeof window !== 'undefined' ? parseUrl(window.location.origin).origin : '',\n      basePath: typeof window !== 'undefined' ? parseUrl(window.location.origin).path : '/api/auth',\n      credentials: 'same-origin',\n      lastSync: 0,\n      session: null,\n      fetchSession: async () => void 0,\n    }\n  }\n\n  static getInstance(): AuthConfigManager {\n    if (!AuthConfigManager.instance) {\n      AuthConfigManager.instance = new AuthConfigManager()\n    }\n    return AuthConfigManager.instance\n  }\n\n  setConfig(userConfig: Partial<AuthClientConfig>): void {\n    const normalized = normalizeBasePath(userConfig)\n    this.config = { ...this.config, ...normalized }\n  }\n\n  getConfig(): AuthClientConfig {\n    return this.config\n  }\n\n  initializeConfig(hasInitialSession: boolean): void {\n    this.config.lastSync = hasInitialSession ? now() : 0\n  }\n}\n\nexport const authConfigManager: AuthConfigManager = AuthConfigManager.getInstance()\n\nexport const SessionContext: React.Context<SessionContextValue | undefined> = React.createContext<\n  SessionContextValue | undefined\n>(undefined)\n\nfunction useInitializeSession(hasInitialSession: boolean, initialSession: Session | null) {\n  const authConfig = authConfigManager.getConfig()\n  const [session, setSession] = React.useState<Session | null>(initialSession)\n  const [loading, setLoading] = React.useState(!hasInitialSession)\n\n  useEffect(() => {\n    authConfig.fetchSession = async ({ event } = {}) => {\n      try {\n        const isStorageEvent = event === 'storage'\n\n        if (isStorageEvent || !authConfig.session) {\n          authConfig.lastSync = now()\n          authConfig.session = await getSession()\n          setSession(authConfig.session)\n          return\n        }\n\n        if (!event || !authConfig.session || now() < authConfig.lastSync) {\n          return\n        }\n\n        authConfig.lastSync = now()\n        authConfig.session = await getSession()\n        setSession(authConfig.session)\n      } catch (error) {\n        logger.error(new ClientSessionError((error as Error).message, error as any))\n      } finally {\n        setLoading(false)\n      }\n    }\n\n    authConfig.fetchSession()\n\n    return () => {\n      authConfig.lastSync = 0\n      authConfig.session = null\n      authConfig.fetchSession = async () => void 0\n    }\n  }, [])\n\n  return { session, setSession, loading, setLoading }\n}\n\nfunction useVisibilityChangeEventListener(\n  authConfig: AuthClientConfig,\n  refetchOnWindowFocus: boolean\n) {\n  useEffect(() => {\n    const abortController = new AbortController()\n    const handleVisibilityChange = () => {\n      if (refetchOnWindowFocus && document.visibilityState === 'visible') {\n        authConfig.fetchSession({ event: 'visibilitychange' })\n      }\n    }\n    document.addEventListener('visibilitychange', handleVisibilityChange, {\n      signal: abortController.signal,\n    })\n\n    return () => {\n      abortController.abort()\n    }\n  }, [refetchOnWindowFocus])\n}\n\nfunction useRefetchInterval(\n  authConfig: AuthClientConfig,\n  refetchInterval?: number,\n  shouldRefetch?: boolean\n) {\n  useEffect(() => {\n    if (refetchInterval && shouldRefetch) {\n      const intervalId = setInterval(() => {\n        if (authConfig.session) {\n          authConfig.fetchSession({ event: 'poll' })\n        }\n      }, refetchInterval * 1000)\n      return () => {\n        clearInterval(intervalId)\n      }\n    }\n  }, [refetchInterval, shouldRefetch])\n}\n\nexport async function getSession(params?: GetSessionParams): Promise<Session | null> {\n  const { baseUrl, basePath, credentials } = authConfigManager.getConfig()\n  const session = await fetchData<Session>(\n    'session',\n    {\n      baseUrl,\n      basePath,\n      credentials,\n    },\n    logger,\n    params\n  )\n  return session\n}\n\nexport async function getCsrfToken(): Promise<string> {\n  const { baseUrl, basePath, credentials } = authConfigManager.getConfig()\n  const response = await fetchData<{ csrfToken: string }>(\n    'csrf',\n    {\n      baseUrl,\n      basePath,\n      credentials,\n    },\n    logger\n  )\n  return response?.csrfToken ?? ''\n}\n\nexport function SessionProvider(props: SessionProviderProps): React.JSX.Element {\n  if (!SessionContext) {\n    throw new Error('React Context is unavailable in Server Components')\n  }\n\n  const { children, refetchInterval, refetchWhenOffline = true } = props\n\n  const authConfig = authConfigManager.getConfig()\n\n  const hasInitialSession = !!props.session\n\n  authConfigManager.initializeConfig(hasInitialSession)\n\n  const { session, setSession, loading, setLoading } = useInitializeSession(\n    hasInitialSession,\n    props.session ?? null\n  )\n\n  useVisibilityChangeEventListener(authConfig, props.refetchOnWindowFocus ?? true)\n\n  const isOnline = useOnline()\n\n  const shouldRefetch = refetchWhenOffline || isOnline\n\n  useRefetchInterval(authConfig, refetchInterval, shouldRefetch)\n\n  const contextValue: SessionContextValue = useMemo(\n    () =>\n      ({\n        data: session,\n        status: loading ? 'loading' : session ? 'authenticated' : 'unauthenticated',\n        update: async (data) => {\n          if (loading || !session) {\n            return\n          }\n          setLoading(true)\n          const updatedSession = await fetchData<Session>(\n            'session',\n            authConfig,\n            logger,\n            data ? { body: { csrfToken: await getCsrfToken(), data } } : undefined\n          )\n          setLoading(false)\n          if (updatedSession) {\n            setSession(updatedSession)\n          }\n          return updatedSession\n        },\n      }) as SessionContextValue,\n    [session, loading, setSession]\n  )\n\n  return <SessionContext.Provider value={contextValue}>{children}</SessionContext.Provider>\n}\n\nexport function useSession<R extends boolean>(\n  options?: UseSessionOptions<R>\n): SessionContextValue<R> {\n  if (!SessionContext) {\n    throw new Error('React Context is unavailable in Server Components')\n  }\n\n  const config = authConfigManager.getConfig()\n\n  const session = useContext(SessionContext)\n\n  const { required, onUnauthenticated } = options ?? {}\n\n  const requiredAndNotLoading = required && session?.status === 'unauthenticated'\n\n  useEffect(() => {\n    if (requiredAndNotLoading) {\n      const url = `${config.baseUrl}${config.basePath}/signin?${new URLSearchParams({\n        error: 'SessionRequired',\n        callbackUrl: window.location.href,\n      })}`\n      if (onUnauthenticated) {\n        onUnauthenticated()\n      } else {\n        window.location.href = url\n      }\n    }\n  }, [requiredAndNotLoading, onUnauthenticated])\n\n  if (requiredAndNotLoading) {\n    return {\n      data: session?.data,\n      update: session?.update,\n      status: 'loading',\n    }\n  }\n\n  return session as SessionContextValue<R>\n}\n\ntype ProvidersType = Record<LiteralUnion<BuiltInProviderType>, ClientSafeProvider>\n\nexport async function getProviders(): Promise<ProvidersType | null> {\n  return fetchData<ProvidersType>('providers', authConfigManager.getConfig(), logger)\n}\n\nexport async function signIn<P extends RedirectableProviderType | undefined = undefined>(\n  provider?: LiteralUnion<\n    P extends RedirectableProviderType ? P | BuiltInProviderType : BuiltInProviderType\n  >,\n  options: SignInOptions = {},\n  authorizationParams: SignInAuthorizationParams = {}\n): Promise<P extends RedirectableProviderType ? SignInResponse | undefined : undefined> {\n  const { callbackUrl = window.location.href, redirect = true, ...opts } = options\n\n  const config = authConfigManager.getConfig()\n\n  const href = `${config.baseUrl}${config.basePath}`\n\n  const providers = await getProviders()\n  if (!providers) {\n    window.location.href = `${href}/error`\n    return\n  }\n\n  if (!provider || !(provider in providers)) {\n    window.location.href = `${href}/signin?${new URLSearchParams({ callbackUrl })}`\n    return\n  }\n\n  const isCredentials = providers[provider].type === 'credentials'\n  const isEmail = providers[provider].type === 'email'\n\n  const signInUrl = `${href}/${isCredentials ? 'callback' : 'signin'}/${provider}`\n\n  const csrfToken = await getCsrfToken()\n  const res = await fetch(`${signInUrl}?${new URLSearchParams(authorizationParams)}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'X-Auth-Return-Redirect': '1',\n    },\n    body: new URLSearchParams({ ...opts, csrfToken, callbackUrl }),\n    credentials: config.credentials,\n  })\n\n  const data = (await res.json()) as { url: string }\n\n  if (redirect) {\n    const url = data.url ?? callbackUrl\n    window.location.href = url\n\n    if (url.includes('#')) {\n      window.location.reload()\n    }\n    return\n  }\n\n  const error = new URL(data.url).searchParams.get('error')\n\n  if (res.ok) {\n    await config.fetchSession?.({ event: 'storage' })\n  }\n\n  return {\n    error,\n    status: res.status,\n    ok: res.ok,\n    url: error ? null : data.url,\n  } as P extends RedirectableProviderType ? SignInResponse : undefined\n}\n\nexport async function signOut<R extends boolean = true>(\n  options?: SignOutParams<R>\n): Promise<R extends true ? undefined : SignOutResponse> {\n  const { callbackUrl = window.location.href, redirect = true } = options ?? {}\n  const config = authConfigManager.getConfig()\n\n  const csrfToken = await getCsrfToken()\n  const res = await fetch(`${config.baseUrl}${config.basePath}/signout`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'X-Auth-Return-Redirect': '1',\n    },\n    body: new URLSearchParams({ csrfToken, callbackUrl }),\n    credentials: config.credentials,\n  })\n\n  const data = (await res.json()) as { url: string }\n\n  if (redirect) {\n    const url = data.url ?? callbackUrl\n    window.location.href = url\n\n    if (url.includes('#')) {\n      window.location.reload()\n    }\n\n    return undefined as R extends true ? undefined : SignOutResponse\n  }\n\n  await config.fetchSession?.({ event: 'storage' })\n\n  return data as R extends true ? undefined : SignOutResponse\n}\n\nconst createPopup = ({ url, title, height, width }: WindowProps) => {\n  const left = window.screenX + (window.outerWidth - width) / 2\n  const top = window.screenY + (window.outerHeight - height) / 2.5\n  const externalPopup = window.open(\n    url,\n    title,\n    `width=${width},height=${height},left=${left},top=${top}`\n  )\n  return externalPopup\n}\n\ninterface PopupLoginOptions extends Partial<Omit<WindowProps, 'url'>> {\n  onSuccess?: () => void\n  callbackUrl?: string\n}\n\ninterface LoginState extends AuthState {\n  popUpSignin: () => Promise<void>\n}\n\nexport const useOauthPopupLogin = (\n  provider: Parameters<typeof signIn>[0],\n  options: PopupLoginOptions = {}\n): LoginState => {\n  const { width = 500, height = 500, title = 'Signin', onSuccess, callbackUrl = '/' } = options\n\n  const [externalWindow, setExternalWindow] = useState<Window | null>()\n\n  const [state, setState] = useState<AuthState>({ status: 'loading' })\n\n  const popUpSignin = useCallback(async () => {\n    const res = await signIn(provider, {\n      redirect: false,\n      callbackUrl,\n    })\n\n    if (res?.error) {\n      setState({ status: 'errored', error: res.error })\n      return\n    }\n    setExternalWindow(\n      createPopup({\n        url: res?.url as string,\n        title,\n        width,\n        height,\n      })\n    )\n  }, [])\n\n  useEffect(() => {\n    const handleMessage = (event: MessageEvent<AuthState>) => {\n      if (event.origin !== window.location.origin) {\n        return\n      }\n      if (event.data.status) {\n        setState(event.data)\n        if (event.data.status === 'success') {\n          onSuccess?.()\n        }\n        externalWindow?.close()\n      }\n    }\n\n    window.addEventListener('message', handleMessage)\n\n    return () => {\n      window.removeEventListener('message', handleMessage)\n      externalWindow?.close()\n    }\n  }, [externalWindow])\n\n  return { popUpSignin, ...state }\n}\n"],
  "mappings": "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",
  "names": ["options: RequestInit", "_a", "logger: LoggerInstance", "authConfigManager: AuthConfigManager", "SessionContext: React.Context<SessionContextValue | undefined>", "contextValue: SessionContextValue"]
}
