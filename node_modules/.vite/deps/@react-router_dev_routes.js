import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-OL46QLBJ.js";

// node_modules/pathe/dist/shared/pathe.1f0a373c.cjs
var require_pathe_1f0a373c = __commonJS({
  "node_modules/pathe/dist/shared/pathe.1f0a373c.cjs"(exports) {
    "use strict";
    var _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
    function normalizeWindowsPath(input = "") {
      if (!input) {
        return input;
      }
      return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
    }
    var _UNC_REGEX = /^[/\\]{2}/;
    var _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
    var _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
    var _ROOT_FOLDER_RE = /^\/([A-Za-z]:)?$/;
    var sep = "/";
    var delimiter = ":";
    var normalize = function(path2) {
      if (path2.length === 0) {
        return ".";
      }
      path2 = normalizeWindowsPath(path2);
      const isUNCPath = path2.match(_UNC_REGEX);
      const isPathAbsolute = isAbsolute(path2);
      const trailingSeparator = path2[path2.length - 1] === "/";
      path2 = normalizeString(path2, !isPathAbsolute);
      if (path2.length === 0) {
        if (isPathAbsolute) {
          return "/";
        }
        return trailingSeparator ? "./" : ".";
      }
      if (trailingSeparator) {
        path2 += "/";
      }
      if (_DRIVE_LETTER_RE.test(path2)) {
        path2 += "/";
      }
      if (isUNCPath) {
        if (!isPathAbsolute) {
          return `//./${path2}`;
        }
        return `//${path2}`;
      }
      return isPathAbsolute && !isAbsolute(path2) ? `/${path2}` : path2;
    };
    var join = function(...arguments_) {
      if (arguments_.length === 0) {
        return ".";
      }
      let joined;
      for (const argument of arguments_) {
        if (argument && argument.length > 0) {
          if (joined === void 0) {
            joined = argument;
          } else {
            joined += `/${argument}`;
          }
        }
      }
      if (joined === void 0) {
        return ".";
      }
      return normalize(joined.replace(/\/\/+/g, "/"));
    };
    function cwd() {
      if (typeof process !== "undefined" && typeof process.cwd === "function") {
        return process.cwd().replace(/\\/g, "/");
      }
      return "/";
    }
    var resolve = function(...arguments_) {
      arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
      let resolvedPath = "";
      let resolvedAbsolute = false;
      for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
        const path2 = index >= 0 ? arguments_[index] : cwd();
        if (!path2 || path2.length === 0) {
          continue;
        }
        resolvedPath = `${path2}/${resolvedPath}`;
        resolvedAbsolute = isAbsolute(path2);
      }
      resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
        return `/${resolvedPath}`;
      }
      return resolvedPath.length > 0 ? resolvedPath : ".";
    };
    function normalizeString(path2, allowAboveRoot) {
      let res = "";
      let lastSegmentLength = 0;
      let lastSlash = -1;
      let dots = 0;
      let char = null;
      for (let index = 0; index <= path2.length; ++index) {
        if (index < path2.length) {
          char = path2[index];
        } else if (char === "/") {
          break;
        } else {
          char = "/";
        }
        if (char === "/") {
          if (lastSlash === index - 1 || dots === 1) ;
          else if (dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
              if (res.length > 2) {
                const lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = index;
                dots = 0;
                continue;
              } else if (res.length > 0) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = index;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              res += res.length > 0 ? "/.." : "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0) {
              res += `/${path2.slice(lastSlash + 1, index)}`;
            } else {
              res = path2.slice(lastSlash + 1, index);
            }
            lastSegmentLength = index - lastSlash - 1;
          }
          lastSlash = index;
          dots = 0;
        } else if (char === "." && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    var isAbsolute = function(p) {
      return _IS_ABSOLUTE_RE.test(p);
    };
    var toNamespacedPath = function(p) {
      return normalizeWindowsPath(p);
    };
    var _EXTNAME_RE = /.(\.[^./]+)$/;
    var extname = function(p) {
      const match = _EXTNAME_RE.exec(normalizeWindowsPath(p));
      return match && match[1] || "";
    };
    var relative2 = function(from, to) {
      const _from = resolve(from).replace(_ROOT_FOLDER_RE, "$1").split("/");
      const _to = resolve(to).replace(_ROOT_FOLDER_RE, "$1").split("/");
      if (_to[0][1] === ":" && _from[0][1] === ":" && _from[0] !== _to[0]) {
        return _to.join("/");
      }
      const _fromCopy = [..._from];
      for (const segment of _fromCopy) {
        if (_to[0] !== segment) {
          break;
        }
        _from.shift();
        _to.shift();
      }
      return [..._from.map(() => ".."), ..._to].join("/");
    };
    var dirname = function(p) {
      const segments = normalizeWindowsPath(p).replace(/\/$/, "").split("/").slice(0, -1);
      if (segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0])) {
        segments[0] += "/";
      }
      return segments.join("/") || (isAbsolute(p) ? "/" : ".");
    };
    var format = function(p) {
      const segments = [p.root, p.dir, p.base ?? p.name + p.ext].filter(Boolean);
      return normalizeWindowsPath(
        p.root ? resolve(...segments) : segments.join("/")
      );
    };
    var basename = function(p, extension) {
      const lastSegment = normalizeWindowsPath(p).split("/").pop();
      return extension && lastSegment.endsWith(extension) ? lastSegment.slice(0, -extension.length) : lastSegment;
    };
    var parse = function(p) {
      const root2 = normalizeWindowsPath(p).split("/").shift() || "/";
      const base = basename(p);
      const extension = extname(base);
      return {
        root: root2,
        dir: dirname(p),
        base,
        ext: extension,
        name: base.slice(0, base.length - extension.length)
      };
    };
    var path = {
      __proto__: null,
      basename,
      delimiter,
      dirname,
      extname,
      format,
      isAbsolute,
      join,
      normalize,
      normalizeString,
      parse,
      relative: relative2,
      resolve,
      sep,
      toNamespacedPath
    };
    exports.basename = basename;
    exports.delimiter = delimiter;
    exports.dirname = dirname;
    exports.extname = extname;
    exports.format = format;
    exports.isAbsolute = isAbsolute;
    exports.join = join;
    exports.normalize = normalize;
    exports.normalizeString = normalizeString;
    exports.normalizeWindowsPath = normalizeWindowsPath;
    exports.parse = parse;
    exports.path = path;
    exports.relative = relative2;
    exports.resolve = resolve;
    exports.sep = sep;
    exports.toNamespacedPath = toNamespacedPath;
  }
});

// node_modules/pathe/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/pathe/dist/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index = require_pathe_1f0a373c();
    exports.basename = index.basename;
    exports.default = index.path;
    exports.delimiter = index.delimiter;
    exports.dirname = index.dirname;
    exports.extname = index.extname;
    exports.format = index.format;
    exports.isAbsolute = index.isAbsolute;
    exports.join = index.join;
    exports.normalize = index.normalize;
    exports.normalizeString = index.normalizeString;
    exports.parse = index.parse;
    exports.relative = index.relative;
    exports.resolve = index.resolve;
    exports.sep = index.sep;
    exports.toNamespacedPath = index.toNamespacedPath;
  }
});

// node_modules/valibot/dist/index.cjs
var require_dist2 = __commonJS({
  "node_modules/valibot/dist/index.cjs"(exports) {
    var store$4;
    function setGlobalConfig(config$1) {
      store$4 = {
        ...store$4,
        ...config$1
      };
    }
    function getGlobalConfig(config$1) {
      return {
        lang: (config$1 == null ? void 0 : config$1.lang) ?? (store$4 == null ? void 0 : store$4.lang),
        message: config$1 == null ? void 0 : config$1.message,
        abortEarly: (config$1 == null ? void 0 : config$1.abortEarly) ?? (store$4 == null ? void 0 : store$4.abortEarly),
        abortPipeEarly: (config$1 == null ? void 0 : config$1.abortPipeEarly) ?? (store$4 == null ? void 0 : store$4.abortPipeEarly)
      };
    }
    function deleteGlobalConfig() {
      store$4 = void 0;
    }
    var store$3;
    function setGlobalMessage(message$1, lang) {
      if (!store$3) store$3 = /* @__PURE__ */ new Map();
      store$3.set(lang, message$1);
    }
    function getGlobalMessage(lang) {
      return store$3 == null ? void 0 : store$3.get(lang);
    }
    function deleteGlobalMessage(lang) {
      store$3 == null ? void 0 : store$3.delete(lang);
    }
    var store$2;
    function setSchemaMessage(message$1, lang) {
      if (!store$2) store$2 = /* @__PURE__ */ new Map();
      store$2.set(lang, message$1);
    }
    function getSchemaMessage(lang) {
      return store$2 == null ? void 0 : store$2.get(lang);
    }
    function deleteSchemaMessage(lang) {
      store$2 == null ? void 0 : store$2.delete(lang);
    }
    var store$1;
    function setSpecificMessage(reference, message$1, lang) {
      if (!store$1) store$1 = /* @__PURE__ */ new Map();
      if (!store$1.get(reference)) store$1.set(reference, /* @__PURE__ */ new Map());
      store$1.get(reference).set(lang, message$1);
    }
    function getSpecificMessage(reference, lang) {
      var _a;
      return (_a = store$1 == null ? void 0 : store$1.get(reference)) == null ? void 0 : _a.get(lang);
    }
    function deleteSpecificMessage(reference, lang) {
      var _a;
      (_a = store$1 == null ? void 0 : store$1.get(reference)) == null ? void 0 : _a.delete(lang);
    }
    function _stringify(input) {
      var _a, _b;
      const type = typeof input;
      if (type === "string") return `"${input}"`;
      if (type === "number" || type === "bigint" || type === "boolean") return `${input}`;
      if (type === "object" || type === "function") return (input && ((_b = (_a = Object.getPrototypeOf(input)) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name)) ?? "null";
      return type;
    }
    function _addIssue(context, label, dataset, config$1, other) {
      const input = other && "input" in other ? other.input : dataset.value;
      const expected = (other == null ? void 0 : other.expected) ?? context.expects ?? null;
      const received = (other == null ? void 0 : other.received) ?? _stringify(input);
      const issue = {
        kind: context.kind,
        type: context.type,
        input,
        expected,
        received,
        message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
        requirement: context.requirement,
        path: other == null ? void 0 : other.path,
        issues: other == null ? void 0 : other.issues,
        lang: config$1.lang,
        abortEarly: config$1.abortEarly,
        abortPipeEarly: config$1.abortPipeEarly
      };
      const isSchema = context.kind === "schema";
      const message$1 = (other == null ? void 0 : other.message) ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config$1.message ?? getGlobalMessage(issue.lang);
      if (message$1 !== void 0) issue.message = typeof message$1 === "function" ? message$1(issue) : message$1;
      if (isSchema) dataset.typed = false;
      if (dataset.issues) dataset.issues.push(issue);
      else dataset.issues = [issue];
    }
    var textEncoder;
    function _getByteCount(input) {
      if (!textEncoder) textEncoder = new TextEncoder();
      return textEncoder.encode(input).length;
    }
    var segmenter;
    function _getGraphemeCount(input) {
      if (!segmenter) segmenter = new Intl.Segmenter();
      const segments = segmenter.segment(input);
      let count = 0;
      for (const _ of segments) count++;
      return count;
    }
    function _getLastMetadata(schema, type) {
      if ("pipe" in schema) {
        const nestedSchemas = [];
        for (let index = schema.pipe.length - 1; index >= 0; index--) {
          const item = schema.pipe[index];
          if (item.kind === "schema" && "pipe" in item) nestedSchemas.push(item);
          else if (item.kind === "metadata" && item.type === type) return item[type];
        }
        for (const nestedSchema of nestedSchemas) {
          const result = _getLastMetadata(nestedSchema, type);
          if (result !== void 0) return result;
        }
      }
    }
    function _getStandardProps(context) {
      return {
        version: 1,
        vendor: "valibot",
        validate(value$1) {
          return context["~run"]({ value: value$1 }, getGlobalConfig());
        }
      };
    }
    var store;
    function _getWordCount(locales, input) {
      if (!store) store = /* @__PURE__ */ new Map();
      if (!store.get(locales)) store.set(locales, new Intl.Segmenter(locales, { granularity: "word" }));
      const segments = store.get(locales).segment(input);
      let count = 0;
      for (const segment of segments) if (segment.isWordLike) count++;
      return count;
    }
    var NON_DIGIT_REGEX = /\D/gu;
    function _isLuhnAlgo(input) {
      const number$1 = input.replace(NON_DIGIT_REGEX, "");
      let length$1 = number$1.length;
      let bit = 1;
      let sum = 0;
      while (length$1) {
        const value$1 = +number$1[--length$1];
        bit ^= 1;
        sum += bit ? [
          0,
          2,
          4,
          6,
          8,
          1,
          3,
          5,
          7,
          9
        ][value$1] : value$1;
      }
      return sum % 10 === 0;
    }
    function _isValidObjectKey(object$1, key) {
      return Object.hasOwn(object$1, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
    }
    function _joinExpects(values$1, separator) {
      const list = [...new Set(values$1)];
      if (list.length > 1) return `(${list.join(` ${separator} `)})`;
      return list[0] ?? "never";
    }
    function entriesFromList(list, schema) {
      const entries$1 = {};
      for (const key of list) entries$1[key] = schema;
      return entries$1;
    }
    function entriesFromObjects(schemas) {
      const entries$1 = {};
      for (const schema of schemas) Object.assign(entries$1, schema.entries);
      return entries$1;
    }
    function getDotPath(issue) {
      if (issue.path) {
        let key = "";
        for (const item of issue.path) if (typeof item.key === "string" || typeof item.key === "number") if (key) key += `.${item.key}`;
        else key += item.key;
        else return null;
        return key;
      }
      return null;
    }
    function isOfKind(kind, object$1) {
      return object$1.kind === kind;
    }
    function isOfType(type, object$1) {
      return object$1.type === type;
    }
    function isValiError(error) {
      return error instanceof ValiError;
    }
    var ValiError = class extends Error {
      /**
      * Creates a Valibot error with useful information.
      *
      * @param issues The error issues.
      */
      constructor(issues) {
        super(issues[0].message);
        this.name = "ValiError";
        this.issues = issues;
      }
    };
    function args(schema) {
      return {
        kind: "transformation",
        type: "args",
        reference: args,
        async: false,
        schema,
        "~run"(dataset, config$1) {
          const func = dataset.value;
          dataset.value = (...args_) => {
            const argsDataset = this.schema["~run"]({ value: args_ }, config$1);
            if (argsDataset.issues) throw new ValiError(argsDataset.issues);
            return func(...argsDataset.value);
          };
          return dataset;
        }
      };
    }
    function argsAsync(schema) {
      return {
        kind: "transformation",
        type: "args",
        reference: argsAsync,
        async: false,
        schema,
        "~run"(dataset, config$1) {
          const func = dataset.value;
          dataset.value = async (...args$1) => {
            const argsDataset = await schema["~run"]({ value: args$1 }, config$1);
            if (argsDataset.issues) throw new ValiError(argsDataset.issues);
            return func(...argsDataset.value);
          };
          return dataset;
        }
      };
    }
    function awaitAsync() {
      return {
        kind: "transformation",
        type: "await",
        reference: awaitAsync,
        async: true,
        async "~run"(dataset) {
          dataset.value = await dataset.value;
          return dataset;
        }
      };
    }
    var BASE64_REGEX = /^(?:[\da-z+/]{4})*(?:[\da-z+/]{2}==|[\da-z+/]{3}=)?$/iu;
    var BIC_REGEX = /^[A-Z]{6}(?!00)[\dA-Z]{2}(?:[\dA-Z]{3})?$/u;
    var CUID2_REGEX = /^[a-z][\da-z]*$/u;
    var DECIMAL_REGEX = /^[+-]?(?:\d*\.)?\d+$/u;
    var DIGITS_REGEX = /^\d+$/u;
    var EMAIL_REGEX = /^[\w+-]+(?:\.[\w+-]+)*@[\da-z]+(?:[.-][\da-z]+)*\.[a-z]{2,}$/iu;
    var EMOJI_REGEX = new RegExp("^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation}))*)+$", "u");
    var HEXADECIMAL_REGEX = /^(?:0[hx])?[\da-fA-F]+$/u;
    var HEX_COLOR_REGEX = /^#(?:[\da-fA-F]{3,4}|[\da-fA-F]{6}|[\da-fA-F]{8})$/u;
    var IMEI_REGEX = /^\d{15}$|^\d{2}-\d{6}-\d{6}-\d$/u;
    var IPV4_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$/u;
    var IPV6_REGEX = /^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
    var IP_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$|^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
    var ISO_DATE_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])$/u;
    var ISO_DATE_TIME_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3]):[0-5]\d$/u;
    var ISO_TIME_REGEX = /^(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
    var ISO_TIME_SECOND_REGEX = /^(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}$/u;
    var ISO_TIMESTAMP_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])[T ](?:0\d|1\d|2[0-3])(?::[0-5]\d){2}(?:\.\d{1,9})?(?:Z|[+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?)$/u;
    var ISO_WEEK_REGEX = /^\d{4}-W(?:0[1-9]|[1-4]\d|5[0-3])$/u;
    var MAC48_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$/iu;
    var MAC64_REGEX = /^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
    var MAC_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$|^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
    var NANO_ID_REGEX = /^[\w-]+$/u;
    var OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;
    var RFC_EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    var SLUG_REGEX = /^[\da-z]+(?:[-_][\da-z]+)*$/u;
    var ULID_REGEX = /^[\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;
    var UUID_REGEX = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;
    function base64(message$1) {
      return {
        kind: "validation",
        type: "base64",
        reference: base64,
        async: false,
        expects: null,
        requirement: BASE64_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Base64", dataset, config$1);
          return dataset;
        }
      };
    }
    function bic(message$1) {
      return {
        kind: "validation",
        type: "bic",
        reference: bic,
        async: false,
        expects: null,
        requirement: BIC_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "BIC", dataset, config$1);
          return dataset;
        }
      };
    }
    function brand(name) {
      return {
        kind: "transformation",
        type: "brand",
        reference: brand,
        async: false,
        name,
        "~run"(dataset) {
          return dataset;
        }
      };
    }
    function bytes(requirement, message$1) {
      return {
        kind: "validation",
        type: "bytes",
        reference: bytes,
        async: false,
        expects: `${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed) {
            const length$1 = _getByteCount(dataset.value);
            if (length$1 !== this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
          }
          return dataset;
        }
      };
    }
    function check(requirement, message$1) {
      return {
        kind: "validation",
        type: "check",
        reference: check,
        async: false,
        expects: null,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
          return dataset;
        }
      };
    }
    function checkAsync(requirement, message$1) {
      return {
        kind: "validation",
        type: "check",
        reference: checkAsync,
        async: true,
        expects: null,
        requirement,
        message: message$1,
        async "~run"(dataset, config$1) {
          if (dataset.typed && !await this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
          return dataset;
        }
      };
    }
    function checkItems(requirement, message$1) {
      return {
        kind: "validation",
        type: "check_items",
        reference: checkItems,
        async: false,
        expects: null,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed) for (let index = 0; index < dataset.value.length; index++) {
            const item = dataset.value[index];
            if (!this.requirement(item, index, dataset.value)) _addIssue(this, "item", dataset, config$1, {
              input: item,
              path: [{
                type: "array",
                origin: "value",
                input: dataset.value,
                key: index,
                value: item
              }]
            });
          }
          return dataset;
        }
      };
    }
    function checkItemsAsync(requirement, message$1) {
      return {
        kind: "validation",
        type: "check_items",
        reference: checkItemsAsync,
        async: true,
        expects: null,
        requirement,
        message: message$1,
        async "~run"(dataset, config$1) {
          if (dataset.typed) {
            const requirementResults = await Promise.all(dataset.value.map(this.requirement));
            for (let index = 0; index < dataset.value.length; index++) if (!requirementResults[index]) {
              const item = dataset.value[index];
              _addIssue(this, "item", dataset, config$1, {
                input: item,
                path: [{
                  type: "array",
                  origin: "value",
                  input: dataset.value,
                  key: index,
                  value: item
                }]
              });
            }
          }
          return dataset;
        }
      };
    }
    var CREDIT_CARD_REGEX = /^(?:\d{14,19}|\d{4}(?: \d{3,6}){2,4}|\d{4}(?:-\d{3,6}){2,4})$/u;
    var SANITIZE_REGEX = /[- ]/gu;
    var PROVIDER_REGEX_LIST = [
      /^3[47]\d{13}$/u,
      /^3(?:0[0-5]|[68]\d)\d{11,13}$/u,
      /^6(?:011|5\d{2})\d{12,15}$/u,
      /^(?:2131|1800|35\d{3})\d{11}$/u,
      /^5[1-5]\d{2}|(?:222\d|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/u,
      /^(?:6[27]\d{14,17}|81\d{14,17})$/u,
      /^4\d{12}(?:\d{3,6})?$/u
    ];
    function creditCard(message$1) {
      return {
        kind: "validation",
        type: "credit_card",
        reference: creditCard,
        async: false,
        expects: null,
        requirement(input) {
          let sanitized;
          return CREDIT_CARD_REGEX.test(input) && (sanitized = input.replace(SANITIZE_REGEX, "")) && PROVIDER_REGEX_LIST.some((regex$1) => regex$1.test(sanitized)) && _isLuhnAlgo(sanitized);
        },
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "credit card", dataset, config$1);
          return dataset;
        }
      };
    }
    function cuid2(message$1) {
      return {
        kind: "validation",
        type: "cuid2",
        reference: cuid2,
        async: false,
        expects: null,
        requirement: CUID2_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Cuid2", dataset, config$1);
          return dataset;
        }
      };
    }
    function decimal(message$1) {
      return {
        kind: "validation",
        type: "decimal",
        reference: decimal,
        async: false,
        expects: null,
        requirement: DECIMAL_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "decimal", dataset, config$1);
          return dataset;
        }
      };
    }
    function description(description_) {
      return {
        kind: "metadata",
        type: "description",
        reference: description,
        description: description_
      };
    }
    function digits(message$1) {
      return {
        kind: "validation",
        type: "digits",
        reference: digits,
        async: false,
        expects: null,
        requirement: DIGITS_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "digits", dataset, config$1);
          return dataset;
        }
      };
    }
    function email(message$1) {
      return {
        kind: "validation",
        type: "email",
        reference: email,
        expects: null,
        async: false,
        requirement: EMAIL_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "email", dataset, config$1);
          return dataset;
        }
      };
    }
    function emoji(message$1) {
      return {
        kind: "validation",
        type: "emoji",
        reference: emoji,
        async: false,
        expects: null,
        requirement: EMOJI_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "emoji", dataset, config$1);
          return dataset;
        }
      };
    }
    function empty(message$1) {
      return {
        kind: "validation",
        type: "empty",
        reference: empty,
        async: false,
        expects: "0",
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && dataset.value.length > 0) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
          return dataset;
        }
      };
    }
    function endsWith(requirement, message$1) {
      return {
        kind: "validation",
        type: "ends_with",
        reference: endsWith,
        async: false,
        expects: `"${requirement}"`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !dataset.value.endsWith(this.requirement)) _addIssue(this, "end", dataset, config$1, { received: `"${dataset.value.slice(-this.requirement.length)}"` });
          return dataset;
        }
      };
    }
    function entries(requirement, message$1) {
      return {
        kind: "validation",
        type: "entries",
        reference: entries,
        async: false,
        expects: `${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (!dataset.typed) return dataset;
          const count = Object.keys(dataset.value).length;
          if (dataset.typed && count !== this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
          return dataset;
        }
      };
    }
    function everyItem(requirement, message$1) {
      return {
        kind: "validation",
        type: "every_item",
        reference: everyItem,
        async: false,
        expects: null,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !dataset.value.every(this.requirement)) _addIssue(this, "item", dataset, config$1);
          return dataset;
        }
      };
    }
    function examples(examples_) {
      return {
        kind: "metadata",
        type: "examples",
        reference: examples,
        examples: examples_
      };
    }
    function excludes(requirement, message$1) {
      const received = _stringify(requirement);
      return {
        kind: "validation",
        type: "excludes",
        reference: excludes,
        async: false,
        expects: `!${received}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && dataset.value.includes(this.requirement)) _addIssue(this, "content", dataset, config$1, { received });
          return dataset;
        }
      };
    }
    function filterItems(operation) {
      return {
        kind: "transformation",
        type: "filter_items",
        reference: filterItems,
        async: false,
        operation,
        "~run"(dataset) {
          dataset.value = dataset.value.filter(this.operation);
          return dataset;
        }
      };
    }
    function findItem(operation) {
      return {
        kind: "transformation",
        type: "find_item",
        reference: findItem,
        async: false,
        operation,
        "~run"(dataset) {
          dataset.value = dataset.value.find(this.operation);
          return dataset;
        }
      };
    }
    function finite(message$1) {
      return {
        kind: "validation",
        type: "finite",
        reference: finite,
        async: false,
        expects: null,
        requirement: Number.isFinite,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "finite", dataset, config$1);
          return dataset;
        }
      };
    }
    function flavor(name) {
      return {
        kind: "transformation",
        type: "flavor",
        reference: flavor,
        async: false,
        name,
        "~run"(dataset) {
          return dataset;
        }
      };
    }
    function graphemes(requirement, message$1) {
      return {
        kind: "validation",
        type: "graphemes",
        reference: graphemes,
        async: false,
        expects: `${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed) {
            const count = _getGraphemeCount(dataset.value);
            if (count !== this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
          }
          return dataset;
        }
      };
    }
    function gtValue(requirement, message$1) {
      return {
        kind: "validation",
        type: "gt_value",
        reference: gtValue,
        async: false,
        expects: `>${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !(dataset.value > this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value) });
          return dataset;
        }
      };
    }
    var HASH_LENGTHS = {
      md4: 32,
      md5: 32,
      sha1: 40,
      sha256: 64,
      sha384: 96,
      sha512: 128,
      ripemd128: 32,
      ripemd160: 40,
      tiger128: 32,
      tiger160: 40,
      tiger192: 48,
      crc32: 8,
      crc32b: 8,
      adler32: 8
    };
    function hash(types, message$1) {
      return {
        kind: "validation",
        type: "hash",
        reference: hash,
        expects: null,
        async: false,
        requirement: RegExp(types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join("|"), "iu"),
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hash", dataset, config$1);
          return dataset;
        }
      };
    }
    function hexadecimal(message$1) {
      return {
        kind: "validation",
        type: "hexadecimal",
        reference: hexadecimal,
        async: false,
        expects: null,
        requirement: HEXADECIMAL_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hexadecimal", dataset, config$1);
          return dataset;
        }
      };
    }
    function hexColor(message$1) {
      return {
        kind: "validation",
        type: "hex_color",
        reference: hexColor,
        async: false,
        expects: null,
        requirement: HEX_COLOR_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "hex color", dataset, config$1);
          return dataset;
        }
      };
    }
    function imei(message$1) {
      return {
        kind: "validation",
        type: "imei",
        reference: imei,
        async: false,
        expects: null,
        requirement(input) {
          return IMEI_REGEX.test(input) && _isLuhnAlgo(input);
        },
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "IMEI", dataset, config$1);
          return dataset;
        }
      };
    }
    function includes(requirement, message$1) {
      const expects = _stringify(requirement);
      return {
        kind: "validation",
        type: "includes",
        reference: includes,
        async: false,
        expects,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !dataset.value.includes(this.requirement)) _addIssue(this, "content", dataset, config$1, { received: `!${expects}` });
          return dataset;
        }
      };
    }
    function integer(message$1) {
      return {
        kind: "validation",
        type: "integer",
        reference: integer,
        async: false,
        expects: null,
        requirement: Number.isInteger,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "integer", dataset, config$1);
          return dataset;
        }
      };
    }
    function ip(message$1) {
      return {
        kind: "validation",
        type: "ip",
        reference: ip,
        async: false,
        expects: null,
        requirement: IP_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IP", dataset, config$1);
          return dataset;
        }
      };
    }
    function ipv4(message$1) {
      return {
        kind: "validation",
        type: "ipv4",
        reference: ipv4,
        async: false,
        expects: null,
        requirement: IPV4_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IPv4", dataset, config$1);
          return dataset;
        }
      };
    }
    function ipv6(message$1) {
      return {
        kind: "validation",
        type: "ipv6",
        reference: ipv6,
        async: false,
        expects: null,
        requirement: IPV6_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "IPv6", dataset, config$1);
          return dataset;
        }
      };
    }
    function isoDate(message$1) {
      return {
        kind: "validation",
        type: "iso_date",
        reference: isoDate,
        async: false,
        expects: null,
        requirement: ISO_DATE_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "date", dataset, config$1);
          return dataset;
        }
      };
    }
    function isoDateTime(message$1) {
      return {
        kind: "validation",
        type: "iso_date_time",
        reference: isoDateTime,
        async: false,
        expects: null,
        requirement: ISO_DATE_TIME_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "date-time", dataset, config$1);
          return dataset;
        }
      };
    }
    function isoTime(message$1) {
      return {
        kind: "validation",
        type: "iso_time",
        reference: isoTime,
        async: false,
        expects: null,
        requirement: ISO_TIME_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "time", dataset, config$1);
          return dataset;
        }
      };
    }
    function isoTimeSecond(message$1) {
      return {
        kind: "validation",
        type: "iso_time_second",
        reference: isoTimeSecond,
        async: false,
        expects: null,
        requirement: ISO_TIME_SECOND_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "time-second", dataset, config$1);
          return dataset;
        }
      };
    }
    function isoTimestamp(message$1) {
      return {
        kind: "validation",
        type: "iso_timestamp",
        reference: isoTimestamp,
        async: false,
        expects: null,
        requirement: ISO_TIMESTAMP_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "timestamp", dataset, config$1);
          return dataset;
        }
      };
    }
    function isoWeek(message$1) {
      return {
        kind: "validation",
        type: "iso_week",
        reference: isoWeek,
        async: false,
        expects: null,
        requirement: ISO_WEEK_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "week", dataset, config$1);
          return dataset;
        }
      };
    }
    function length(requirement, message$1) {
      return {
        kind: "validation",
        type: "length",
        reference: length,
        async: false,
        expects: `${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && dataset.value.length !== this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
          return dataset;
        }
      };
    }
    function ltValue(requirement, message$1) {
      return {
        kind: "validation",
        type: "lt_value",
        reference: ltValue,
        async: false,
        expects: `<${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !(dataset.value < this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value) });
          return dataset;
        }
      };
    }
    function mac(message$1) {
      return {
        kind: "validation",
        type: "mac",
        reference: mac,
        async: false,
        expects: null,
        requirement: MAC_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "MAC", dataset, config$1);
          return dataset;
        }
      };
    }
    function mac48(message$1) {
      return {
        kind: "validation",
        type: "mac48",
        reference: mac48,
        async: false,
        expects: null,
        requirement: MAC48_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "48-bit MAC", dataset, config$1);
          return dataset;
        }
      };
    }
    function mac64(message$1) {
      return {
        kind: "validation",
        type: "mac64",
        reference: mac64,
        async: false,
        expects: null,
        requirement: MAC64_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "64-bit MAC", dataset, config$1);
          return dataset;
        }
      };
    }
    function mapItems(operation) {
      return {
        kind: "transformation",
        type: "map_items",
        reference: mapItems,
        async: false,
        operation,
        "~run"(dataset) {
          dataset.value = dataset.value.map(this.operation);
          return dataset;
        }
      };
    }
    function maxBytes(requirement, message$1) {
      return {
        kind: "validation",
        type: "max_bytes",
        reference: maxBytes,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed) {
            const length$1 = _getByteCount(dataset.value);
            if (length$1 > this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
          }
          return dataset;
        }
      };
    }
    function maxEntries(requirement, message$1) {
      return {
        kind: "validation",
        type: "max_entries",
        reference: maxEntries,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (!dataset.typed) return dataset;
          const count = Object.keys(dataset.value).length;
          if (dataset.typed && count > this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
          return dataset;
        }
      };
    }
    function maxGraphemes(requirement, message$1) {
      return {
        kind: "validation",
        type: "max_graphemes",
        reference: maxGraphemes,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed) {
            const count = _getGraphemeCount(dataset.value);
            if (count > this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
          }
          return dataset;
        }
      };
    }
    function maxLength(requirement, message$1) {
      return {
        kind: "validation",
        type: "max_length",
        reference: maxLength,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && dataset.value.length > this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
          return dataset;
        }
      };
    }
    function maxSize(requirement, message$1) {
      return {
        kind: "validation",
        type: "max_size",
        reference: maxSize,
        async: false,
        expects: `<=${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && dataset.value.size > this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
          return dataset;
        }
      };
    }
    function maxValue(requirement, message$1) {
      return {
        kind: "validation",
        type: "max_value",
        reference: maxValue,
        async: false,
        expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !(dataset.value <= this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value) });
          return dataset;
        }
      };
    }
    function maxWords(locales, requirement, message$1) {
      return {
        kind: "validation",
        type: "max_words",
        reference: maxWords,
        async: false,
        expects: `<=${requirement}`,
        locales,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed) {
            const count = _getWordCount(this.locales, dataset.value);
            if (count > this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
          }
          return dataset;
        }
      };
    }
    function metadata(metadata_) {
      return {
        kind: "metadata",
        type: "metadata",
        reference: metadata,
        metadata: metadata_
      };
    }
    function mimeType(requirement, message$1) {
      return {
        kind: "validation",
        type: "mime_type",
        reference: mimeType,
        async: false,
        expects: _joinExpects(requirement.map((option) => `"${option}"`), "|"),
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.includes(dataset.value.type)) _addIssue(this, "MIME type", dataset, config$1, { received: `"${dataset.value.type}"` });
          return dataset;
        }
      };
    }
    function minBytes(requirement, message$1) {
      return {
        kind: "validation",
        type: "min_bytes",
        reference: minBytes,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed) {
            const length$1 = _getByteCount(dataset.value);
            if (length$1 < this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
          }
          return dataset;
        }
      };
    }
    function minEntries(requirement, message$1) {
      return {
        kind: "validation",
        type: "min_entries",
        reference: minEntries,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (!dataset.typed) return dataset;
          const count = Object.keys(dataset.value).length;
          if (dataset.typed && count < this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
          return dataset;
        }
      };
    }
    function minGraphemes(requirement, message$1) {
      return {
        kind: "validation",
        type: "min_graphemes",
        reference: minGraphemes,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed) {
            const count = _getGraphemeCount(dataset.value);
            if (count < this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
          }
          return dataset;
        }
      };
    }
    function minLength(requirement, message$1) {
      return {
        kind: "validation",
        type: "min_length",
        reference: minLength,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && dataset.value.length < this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
          return dataset;
        }
      };
    }
    function minSize(requirement, message$1) {
      return {
        kind: "validation",
        type: "min_size",
        reference: minSize,
        async: false,
        expects: `>=${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && dataset.value.size < this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
          return dataset;
        }
      };
    }
    function minValue(requirement, message$1) {
      return {
        kind: "validation",
        type: "min_value",
        reference: minValue,
        async: false,
        expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !(dataset.value >= this.requirement)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value) });
          return dataset;
        }
      };
    }
    function minWords(locales, requirement, message$1) {
      return {
        kind: "validation",
        type: "min_words",
        reference: minWords,
        async: false,
        expects: `>=${requirement}`,
        locales,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed) {
            const count = _getWordCount(this.locales, dataset.value);
            if (count < this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
          }
          return dataset;
        }
      };
    }
    function multipleOf(requirement, message$1) {
      return {
        kind: "validation",
        type: "multiple_of",
        reference: multipleOf,
        async: false,
        expects: `%${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && dataset.value % this.requirement != 0) _addIssue(this, "multiple", dataset, config$1);
          return dataset;
        }
      };
    }
    function nanoid(message$1) {
      return {
        kind: "validation",
        type: "nanoid",
        reference: nanoid,
        async: false,
        expects: null,
        requirement: NANO_ID_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "Nano ID", dataset, config$1);
          return dataset;
        }
      };
    }
    function nonEmpty(message$1) {
      return {
        kind: "validation",
        type: "non_empty",
        reference: nonEmpty,
        async: false,
        expects: "!0",
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && dataset.value.length === 0) _addIssue(this, "length", dataset, config$1, { received: "0" });
          return dataset;
        }
      };
    }
    function normalize(form) {
      return {
        kind: "transformation",
        type: "normalize",
        reference: normalize,
        async: false,
        form,
        "~run"(dataset) {
          dataset.value = dataset.value.normalize(this.form);
          return dataset;
        }
      };
    }
    function notBytes(requirement, message$1) {
      return {
        kind: "validation",
        type: "not_bytes",
        reference: notBytes,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed) {
            const length$1 = _getByteCount(dataset.value);
            if (length$1 === this.requirement) _addIssue(this, "bytes", dataset, config$1, { received: `${length$1}` });
          }
          return dataset;
        }
      };
    }
    function notEntries(requirement, message$1) {
      return {
        kind: "validation",
        type: "not_entries",
        reference: notEntries,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (!dataset.typed) return dataset;
          const count = Object.keys(dataset.value).length;
          if (dataset.typed && count === this.requirement) _addIssue(this, "entries", dataset, config$1, { received: `${count}` });
          return dataset;
        }
      };
    }
    function notGraphemes(requirement, message$1) {
      return {
        kind: "validation",
        type: "not_graphemes",
        reference: notGraphemes,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed) {
            const count = _getGraphemeCount(dataset.value);
            if (count === this.requirement) _addIssue(this, "graphemes", dataset, config$1, { received: `${count}` });
          }
          return dataset;
        }
      };
    }
    function notLength(requirement, message$1) {
      return {
        kind: "validation",
        type: "not_length",
        reference: notLength,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && dataset.value.length === this.requirement) _addIssue(this, "length", dataset, config$1, { received: `${dataset.value.length}` });
          return dataset;
        }
      };
    }
    function notSize(requirement, message$1) {
      return {
        kind: "validation",
        type: "not_size",
        reference: notSize,
        async: false,
        expects: `!${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && dataset.value.size === this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
          return dataset;
        }
      };
    }
    function notValue(requirement, message$1) {
      return {
        kind: "validation",
        type: "not_value",
        reference: notValue,
        async: false,
        expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value) });
          return dataset;
        }
      };
    }
    function notValues(requirement, message$1) {
      return {
        kind: "validation",
        type: "not_values",
        reference: notValues,
        async: false,
        expects: `!${_joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : _stringify(value$1)), "|")}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value) });
          return dataset;
        }
      };
    }
    function notWords(locales, requirement, message$1) {
      return {
        kind: "validation",
        type: "not_words",
        reference: notWords,
        async: false,
        expects: `!${requirement}`,
        locales,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed) {
            const count = _getWordCount(this.locales, dataset.value);
            if (count === this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
          }
          return dataset;
        }
      };
    }
    function octal(message$1) {
      return {
        kind: "validation",
        type: "octal",
        reference: octal,
        async: false,
        expects: null,
        requirement: OCTAL_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "octal", dataset, config$1);
          return dataset;
        }
      };
    }
    function parseJson(config$1, message$1) {
      return {
        kind: "transformation",
        type: "parse_json",
        reference: parseJson,
        config: config$1,
        message: message$1,
        async: false,
        "~run"(dataset, config$2) {
          var _a;
          try {
            dataset.value = JSON.parse(dataset.value, (_a = this.config) == null ? void 0 : _a.reviver);
          } catch (error) {
            if (error instanceof Error) {
              _addIssue(this, "JSON", dataset, config$2, { received: `"${error.message}"` });
              dataset.typed = false;
            } else throw error;
          }
          return dataset;
        }
      };
    }
    function _isPartiallyTyped(dataset, paths) {
      var _a;
      if (dataset.issues) for (const path of paths) for (const issue of dataset.issues) {
        let typed = false;
        const bound = Math.min(path.length, ((_a = issue.path) == null ? void 0 : _a.length) ?? 0);
        for (let index = 0; index < bound; index++) if (path[index] !== issue.path[index].key && (path[index] !== "$" || issue.path[index].type !== "array")) {
          typed = true;
          break;
        }
        if (!typed) return false;
      }
      return true;
    }
    function partialCheck(paths, requirement, message$1) {
      return {
        kind: "validation",
        type: "partial_check",
        reference: partialCheck,
        async: false,
        expects: null,
        paths,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && !this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
          return dataset;
        }
      };
    }
    function partialCheckAsync(paths, requirement, message$1) {
      return {
        kind: "validation",
        type: "partial_check",
        reference: partialCheckAsync,
        async: true,
        expects: null,
        paths,
        requirement,
        message: message$1,
        async "~run"(dataset, config$1) {
          if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && !await this.requirement(dataset.value)) _addIssue(this, "input", dataset, config$1);
          return dataset;
        }
      };
    }
    function rawCheck(action) {
      return {
        kind: "validation",
        type: "raw_check",
        reference: rawCheck,
        async: false,
        expects: null,
        "~run"(dataset, config$1) {
          action({
            dataset,
            config: config$1,
            addIssue: (info) => _addIssue(this, (info == null ? void 0 : info.label) ?? "input", dataset, config$1, info)
          });
          return dataset;
        }
      };
    }
    function rawCheckAsync(action) {
      return {
        kind: "validation",
        type: "raw_check",
        reference: rawCheckAsync,
        async: true,
        expects: null,
        async "~run"(dataset, config$1) {
          await action({
            dataset,
            config: config$1,
            addIssue: (info) => _addIssue(this, (info == null ? void 0 : info.label) ?? "input", dataset, config$1, info)
          });
          return dataset;
        }
      };
    }
    function rawTransform(action) {
      return {
        kind: "transformation",
        type: "raw_transform",
        reference: rawTransform,
        async: false,
        "~run"(dataset, config$1) {
          const output = action({
            dataset,
            config: config$1,
            addIssue: (info) => _addIssue(this, (info == null ? void 0 : info.label) ?? "input", dataset, config$1, info),
            NEVER: null
          });
          if (dataset.issues) dataset.typed = false;
          else dataset.value = output;
          return dataset;
        }
      };
    }
    function rawTransformAsync(action) {
      return {
        kind: "transformation",
        type: "raw_transform",
        reference: rawTransformAsync,
        async: true,
        async "~run"(dataset, config$1) {
          const output = await action({
            dataset,
            config: config$1,
            addIssue: (info) => _addIssue(this, (info == null ? void 0 : info.label) ?? "input", dataset, config$1, info),
            NEVER: null
          });
          if (dataset.issues) dataset.typed = false;
          else dataset.value = output;
          return dataset;
        }
      };
    }
    function readonly() {
      return {
        kind: "transformation",
        type: "readonly",
        reference: readonly,
        async: false,
        "~run"(dataset) {
          return dataset;
        }
      };
    }
    function reduceItems(operation, initial) {
      return {
        kind: "transformation",
        type: "reduce_items",
        reference: reduceItems,
        async: false,
        operation,
        initial,
        "~run"(dataset) {
          dataset.value = dataset.value.reduce(this.operation, this.initial);
          return dataset;
        }
      };
    }
    function regex(requirement, message$1) {
      return {
        kind: "validation",
        type: "regex",
        reference: regex,
        async: false,
        expects: `${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "format", dataset, config$1);
          return dataset;
        }
      };
    }
    function returns(schema) {
      return {
        kind: "transformation",
        type: "returns",
        reference: returns,
        async: false,
        schema,
        "~run"(dataset, config$1) {
          const func = dataset.value;
          dataset.value = (...args_) => {
            const returnsDataset = this.schema["~run"]({ value: func(...args_) }, config$1);
            if (returnsDataset.issues) throw new ValiError(returnsDataset.issues);
            return returnsDataset.value;
          };
          return dataset;
        }
      };
    }
    function returnsAsync(schema) {
      return {
        kind: "transformation",
        type: "returns",
        reference: returnsAsync,
        async: false,
        schema,
        "~run"(dataset, config$1) {
          const func = dataset.value;
          dataset.value = async (...args_) => {
            const returnsDataset = await this.schema["~run"]({ value: await func(...args_) }, config$1);
            if (returnsDataset.issues) throw new ValiError(returnsDataset.issues);
            return returnsDataset.value;
          };
          return dataset;
        }
      };
    }
    function rfcEmail(message$1) {
      return {
        kind: "validation",
        type: "rfc_email",
        reference: rfcEmail,
        expects: null,
        async: false,
        requirement: RFC_EMAIL_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "email", dataset, config$1);
          return dataset;
        }
      };
    }
    function safeInteger(message$1) {
      return {
        kind: "validation",
        type: "safe_integer",
        reference: safeInteger,
        async: false,
        expects: null,
        requirement: Number.isSafeInteger,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "safe integer", dataset, config$1);
          return dataset;
        }
      };
    }
    function size(requirement, message$1) {
      return {
        kind: "validation",
        type: "size",
        reference: size,
        async: false,
        expects: `${requirement}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && dataset.value.size !== this.requirement) _addIssue(this, "size", dataset, config$1, { received: `${dataset.value.size}` });
          return dataset;
        }
      };
    }
    function slug(message$1) {
      return {
        kind: "validation",
        type: "slug",
        reference: slug,
        async: false,
        expects: null,
        requirement: SLUG_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "slug", dataset, config$1);
          return dataset;
        }
      };
    }
    function someItem(requirement, message$1) {
      return {
        kind: "validation",
        type: "some_item",
        reference: someItem,
        async: false,
        expects: null,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !dataset.value.some(this.requirement)) _addIssue(this, "item", dataset, config$1);
          return dataset;
        }
      };
    }
    function sortItems(operation) {
      return {
        kind: "transformation",
        type: "sort_items",
        reference: sortItems,
        async: false,
        operation,
        "~run"(dataset) {
          dataset.value = dataset.value.sort(this.operation);
          return dataset;
        }
      };
    }
    function startsWith(requirement, message$1) {
      return {
        kind: "validation",
        type: "starts_with",
        reference: startsWith,
        async: false,
        expects: `"${requirement}"`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !dataset.value.startsWith(this.requirement)) _addIssue(this, "start", dataset, config$1, { received: `"${dataset.value.slice(0, this.requirement.length)}"` });
          return dataset;
        }
      };
    }
    function stringifyJson(config$1, message$1) {
      return {
        kind: "transformation",
        type: "stringify_json",
        reference: stringifyJson,
        message: message$1,
        config: config$1,
        async: false,
        "~run"(dataset, config$2) {
          var _a, _b;
          try {
            const output = JSON.stringify(dataset.value, (_a = this.config) == null ? void 0 : _a.replacer, (_b = this.config) == null ? void 0 : _b.space);
            if (output === void 0) {
              _addIssue(this, "JSON", dataset, config$2);
              dataset.typed = false;
            }
            dataset.value = output;
          } catch (error) {
            if (error instanceof Error) {
              _addIssue(this, "JSON", dataset, config$2, { received: `"${error.message}"` });
              dataset.typed = false;
            } else throw error;
          }
          return dataset;
        }
      };
    }
    function title(title_) {
      return {
        kind: "metadata",
        type: "title",
        reference: title,
        title: title_
      };
    }
    function toBigint(message$1) {
      return {
        kind: "transformation",
        type: "to_bigint",
        reference: toBigint,
        async: false,
        message: message$1,
        "~run"(dataset, config$1) {
          try {
            dataset.value = BigInt(dataset.value);
          } catch {
            _addIssue(this, "bigint", dataset, config$1);
            dataset.typed = false;
          }
          return dataset;
        }
      };
    }
    function toBoolean() {
      return {
        kind: "transformation",
        type: "to_boolean",
        reference: toBoolean,
        async: false,
        "~run"(dataset) {
          dataset.value = Boolean(dataset.value);
          return dataset;
        }
      };
    }
    function toDate(message$1) {
      return {
        kind: "transformation",
        type: "to_date",
        reference: toDate,
        async: false,
        message: message$1,
        "~run"(dataset, config$1) {
          try {
            dataset.value = new Date(dataset.value);
            if (isNaN(dataset.value)) {
              _addIssue(this, "date", dataset, config$1, { received: '"Invalid Date"' });
              dataset.typed = false;
            }
          } catch {
            _addIssue(this, "date", dataset, config$1);
            dataset.typed = false;
          }
          return dataset;
        }
      };
    }
    function toLowerCase() {
      return {
        kind: "transformation",
        type: "to_lower_case",
        reference: toLowerCase,
        async: false,
        "~run"(dataset) {
          dataset.value = dataset.value.toLowerCase();
          return dataset;
        }
      };
    }
    function toMaxValue(requirement) {
      return {
        kind: "transformation",
        type: "to_max_value",
        reference: toMaxValue,
        async: false,
        requirement,
        "~run"(dataset) {
          dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;
          return dataset;
        }
      };
    }
    function toMinValue(requirement) {
      return {
        kind: "transformation",
        type: "to_min_value",
        reference: toMinValue,
        async: false,
        requirement,
        "~run"(dataset) {
          dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;
          return dataset;
        }
      };
    }
    function toNumber(message$1) {
      return {
        kind: "transformation",
        type: "to_number",
        reference: toNumber,
        async: false,
        message: message$1,
        "~run"(dataset, config$1) {
          try {
            dataset.value = Number(dataset.value);
            if (isNaN(dataset.value)) {
              _addIssue(this, "number", dataset, config$1);
              dataset.typed = false;
            }
          } catch {
            _addIssue(this, "number", dataset, config$1);
            dataset.typed = false;
          }
          return dataset;
        }
      };
    }
    function toString2(message$1) {
      return {
        kind: "transformation",
        type: "to_string",
        reference: toString2,
        async: false,
        message: message$1,
        "~run"(dataset, config$1) {
          try {
            dataset.value = String(dataset.value);
          } catch {
            _addIssue(this, "string", dataset, config$1);
            dataset.typed = false;
          }
          return dataset;
        }
      };
    }
    function toUpperCase() {
      return {
        kind: "transformation",
        type: "to_upper_case",
        reference: toUpperCase,
        async: false,
        "~run"(dataset) {
          dataset.value = dataset.value.toUpperCase();
          return dataset;
        }
      };
    }
    function transform(operation) {
      return {
        kind: "transformation",
        type: "transform",
        reference: transform,
        async: false,
        operation,
        "~run"(dataset) {
          dataset.value = this.operation(dataset.value);
          return dataset;
        }
      };
    }
    function transformAsync(operation) {
      return {
        kind: "transformation",
        type: "transform",
        reference: transformAsync,
        async: true,
        operation,
        async "~run"(dataset) {
          dataset.value = await this.operation(dataset.value);
          return dataset;
        }
      };
    }
    function trim() {
      return {
        kind: "transformation",
        type: "trim",
        reference: trim,
        async: false,
        "~run"(dataset) {
          dataset.value = dataset.value.trim();
          return dataset;
        }
      };
    }
    function trimEnd() {
      return {
        kind: "transformation",
        type: "trim_end",
        reference: trimEnd,
        async: false,
        "~run"(dataset) {
          dataset.value = dataset.value.trimEnd();
          return dataset;
        }
      };
    }
    function trimStart() {
      return {
        kind: "transformation",
        type: "trim_start",
        reference: trimStart,
        async: false,
        "~run"(dataset) {
          dataset.value = dataset.value.trimStart();
          return dataset;
        }
      };
    }
    function ulid(message$1) {
      return {
        kind: "validation",
        type: "ulid",
        reference: ulid,
        async: false,
        expects: null,
        requirement: ULID_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "ULID", dataset, config$1);
          return dataset;
        }
      };
    }
    function url(message$1) {
      return {
        kind: "validation",
        type: "url",
        reference: url,
        async: false,
        expects: null,
        requirement(input) {
          try {
            new URL(input);
            return true;
          } catch {
            return false;
          }
        },
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, "URL", dataset, config$1);
          return dataset;
        }
      };
    }
    function uuid(message$1) {
      return {
        kind: "validation",
        type: "uuid",
        reference: uuid,
        async: false,
        expects: null,
        requirement: UUID_REGEX,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, "UUID", dataset, config$1);
          return dataset;
        }
      };
    }
    function value(requirement, message$1) {
      return {
        kind: "validation",
        type: "value",
        reference: value,
        async: false,
        expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value) });
          return dataset;
        }
      };
    }
    function values(requirement, message$1) {
      return {
        kind: "validation",
        type: "values",
        reference: values,
        async: false,
        expects: `${_joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : _stringify(value$1)), "|")}`,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed && !this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, "value", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value) });
          return dataset;
        }
      };
    }
    function words(locales, requirement, message$1) {
      return {
        kind: "validation",
        type: "words",
        reference: words,
        async: false,
        expects: `${requirement}`,
        locales,
        requirement,
        message: message$1,
        "~run"(dataset, config$1) {
          if (dataset.typed) {
            const count = _getWordCount(this.locales, dataset.value);
            if (count !== this.requirement) _addIssue(this, "words", dataset, config$1, { received: `${count}` });
          }
          return dataset;
        }
      };
    }
    function assert(schema, input) {
      const issues = schema["~run"]({ value: input }, { abortEarly: true }).issues;
      if (issues) throw new ValiError(issues);
    }
    function config(schema, config$1) {
      return {
        ...schema,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config_) {
          return schema["~run"](dataset, {
            ...config_,
            ...config$1
          });
        }
      };
    }
    function getFallback(schema, dataset, config$1) {
      return typeof schema.fallback === "function" ? schema.fallback(dataset, config$1) : schema.fallback;
    }
    function fallback(schema, fallback$1) {
      return {
        ...schema,
        fallback: fallback$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          const outputDataset = schema["~run"](dataset, config$1);
          return outputDataset.issues ? {
            typed: true,
            value: getFallback(this, outputDataset, config$1)
          } : outputDataset;
        }
      };
    }
    function fallbackAsync(schema, fallback$1) {
      return {
        ...schema,
        fallback: fallback$1,
        async: true,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          const outputDataset = await schema["~run"](dataset, config$1);
          return outputDataset.issues ? {
            typed: true,
            value: await getFallback(this, outputDataset, config$1)
          } : outputDataset;
        }
      };
    }
    function flatten2(issues) {
      const flatErrors = {};
      for (const issue of issues) if (issue.path) {
        const dotPath = getDotPath(issue);
        if (dotPath) {
          if (!flatErrors.nested) flatErrors.nested = {};
          if (flatErrors.nested[dotPath]) flatErrors.nested[dotPath].push(issue.message);
          else flatErrors.nested[dotPath] = [issue.message];
        } else if (flatErrors.other) flatErrors.other.push(issue.message);
        else flatErrors.other = [issue.message];
      } else if (flatErrors.root) flatErrors.root.push(issue.message);
      else flatErrors.root = [issue.message];
      return flatErrors;
    }
    function forward(action, path) {
      return {
        ...action,
        "~run"(dataset, config$1) {
          const prevIssues = dataset.issues && [...dataset.issues];
          dataset = action["~run"](dataset, config$1);
          if (dataset.issues) {
            for (const issue of dataset.issues) if (!(prevIssues == null ? void 0 : prevIssues.includes(issue))) {
              let pathInput = dataset.value;
              for (const key of path) {
                const pathValue = pathInput[key];
                const pathItem = {
                  type: "unknown",
                  origin: "value",
                  input: pathInput,
                  key,
                  value: pathValue
                };
                if (issue.path) issue.path.push(pathItem);
                else issue.path = [pathItem];
                if (!pathValue) break;
                pathInput = pathValue;
              }
            }
          }
          return dataset;
        }
      };
    }
    function forwardAsync(action, path) {
      return {
        ...action,
        async: true,
        async "~run"(dataset, config$1) {
          const prevIssues = dataset.issues && [...dataset.issues];
          dataset = await action["~run"](dataset, config$1);
          if (dataset.issues) {
            for (const issue of dataset.issues) if (!(prevIssues == null ? void 0 : prevIssues.includes(issue))) {
              let pathInput = dataset.value;
              for (const key of path) {
                const pathValue = pathInput[key];
                const pathItem = {
                  type: "unknown",
                  origin: "value",
                  input: pathInput,
                  key,
                  value: pathValue
                };
                if (issue.path) issue.path.push(pathItem);
                else issue.path = [pathItem];
                if (!pathValue) break;
                pathInput = pathValue;
              }
            }
          }
          return dataset;
        }
      };
    }
    function getDefault(schema, dataset, config$1) {
      return typeof schema.default === "function" ? schema.default(dataset, config$1) : schema.default;
    }
    function getDefaults(schema) {
      if ("entries" in schema) {
        const object$1 = {};
        for (const key in schema.entries) object$1[key] = getDefaults(schema.entries[key]);
        return object$1;
      }
      if ("items" in schema) return schema.items.map(getDefaults);
      return getDefault(schema);
    }
    async function getDefaultsAsync(schema) {
      if ("entries" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await getDefaultsAsync(value$1)])));
      if ("items" in schema) return Promise.all(schema.items.map(getDefaultsAsync));
      return getDefault(schema);
    }
    function getDescription(schema) {
      return _getLastMetadata(schema, "description");
    }
    function getExamples(schema) {
      const examples$1 = [];
      function depthFirstCollect(schema$1) {
        if ("pipe" in schema$1) {
          for (const item of schema$1.pipe) if (item.kind === "schema" && "pipe" in item) depthFirstCollect(item);
          else if (item.kind === "metadata" && item.type === "examples") examples$1.push(...item.examples);
        }
      }
      depthFirstCollect(schema);
      return examples$1;
    }
    function getFallbacks(schema) {
      if ("entries" in schema) {
        const object$1 = {};
        for (const key in schema.entries) object$1[key] = getFallbacks(schema.entries[key]);
        return object$1;
      }
      if ("items" in schema) return schema.items.map(getFallbacks);
      return getFallback(schema);
    }
    async function getFallbacksAsync(schema) {
      if ("entries" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await getFallbacksAsync(value$1)])));
      if ("items" in schema) return Promise.all(schema.items.map(getFallbacksAsync));
      return getFallback(schema);
    }
    function getMetadata(schema) {
      const result = {};
      function depthFirstMerge(schema$1) {
        if ("pipe" in schema$1) {
          for (const item of schema$1.pipe) if (item.kind === "schema" && "pipe" in item) depthFirstMerge(item);
          else if (item.kind === "metadata" && item.type === "metadata") Object.assign(result, item.metadata);
        }
      }
      depthFirstMerge(schema);
      return result;
    }
    function getTitle(schema) {
      return _getLastMetadata(schema, "title");
    }
    function is(schema, input) {
      return !schema["~run"]({ value: input }, { abortEarly: true }).issues;
    }
    function any() {
      return {
        kind: "schema",
        type: "any",
        reference: any,
        expects: "any",
        async: false,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset) {
          dataset.typed = true;
          return dataset;
        }
      };
    }
    function array(item, message$1) {
      return {
        kind: "schema",
        type: "array",
        reference: array,
        expects: "Array",
        async: false,
        item,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (Array.isArray(input)) {
            dataset.typed = true;
            dataset.value = [];
            for (let key = 0; key < input.length; key++) {
              const value$1 = input[key];
              const itemDataset = this.item["~run"]({ value: value$1 }, config$1);
              if (itemDataset.issues) {
                const pathItem = {
                  type: "array",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of itemDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = itemDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!itemDataset.typed) dataset.typed = false;
              dataset.value.push(itemDataset.value);
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function arrayAsync(item, message$1) {
      return {
        kind: "schema",
        type: "array",
        reference: arrayAsync,
        expects: "Array",
        async: true,
        item,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (Array.isArray(input)) {
            dataset.typed = true;
            dataset.value = [];
            const itemDatasets = await Promise.all(input.map((value$1) => this.item["~run"]({ value: value$1 }, config$1)));
            for (let key = 0; key < itemDatasets.length; key++) {
              const itemDataset = itemDatasets[key];
              if (itemDataset.issues) {
                const pathItem = {
                  type: "array",
                  origin: "value",
                  input,
                  key,
                  value: input[key]
                };
                for (const issue of itemDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = itemDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!itemDataset.typed) dataset.typed = false;
              dataset.value.push(itemDataset.value);
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function bigint(message$1) {
      return {
        kind: "schema",
        type: "bigint",
        reference: bigint,
        expects: "bigint",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (typeof dataset.value === "bigint") dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function blob(message$1) {
      return {
        kind: "schema",
        type: "blob",
        reference: blob,
        expects: "Blob",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value instanceof Blob) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function boolean(message$1) {
      return {
        kind: "schema",
        type: "boolean",
        reference: boolean,
        expects: "boolean",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (typeof dataset.value === "boolean") dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function custom(check$1, message$1) {
      return {
        kind: "schema",
        type: "custom",
        reference: custom,
        expects: "unknown",
        async: false,
        check: check$1,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (this.check(dataset.value)) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function customAsync(check$1, message$1) {
      return {
        kind: "schema",
        type: "custom",
        reference: customAsync,
        expects: "unknown",
        async: true,
        check: check$1,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          if (await this.check(dataset.value)) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function date(message$1) {
      return {
        kind: "schema",
        type: "date",
        reference: date,
        expects: "Date",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value instanceof Date) if (!isNaN(dataset.value)) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1, { received: '"Invalid Date"' });
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function enum_(enum__, message$1) {
      const options = [];
      for (const key in enum__) if (`${+key}` !== key || typeof enum__[key] !== "string" || !Object.is(enum__[enum__[key]], +key)) options.push(enum__[key]);
      return {
        kind: "schema",
        type: "enum",
        reference: enum_,
        expects: _joinExpects(options.map(_stringify), "|"),
        async: false,
        enum: enum__,
        options,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (this.options.includes(dataset.value)) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function exactOptional(wrapped, default_) {
      return {
        kind: "schema",
        type: "exact_optional",
        reference: exactOptional,
        expects: wrapped.expects,
        async: false,
        wrapped,
        default: default_,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          return this.wrapped["~run"](dataset, config$1);
        }
      };
    }
    function exactOptionalAsync(wrapped, default_) {
      return {
        kind: "schema",
        type: "exact_optional",
        reference: exactOptionalAsync,
        expects: wrapped.expects,
        async: true,
        wrapped,
        default: default_,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          return this.wrapped["~run"](dataset, config$1);
        }
      };
    }
    function file(message$1) {
      return {
        kind: "schema",
        type: "file",
        reference: file,
        expects: "File",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value instanceof File) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function function_(message$1) {
      return {
        kind: "schema",
        type: "function",
        reference: function_,
        expects: "Function",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (typeof dataset.value === "function") dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function instance(class_, message$1) {
      return {
        kind: "schema",
        type: "instance",
        reference: instance,
        expects: class_.name,
        async: false,
        class: class_,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value instanceof this.class) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function _merge(value1, value2) {
      if (typeof value1 === typeof value2) {
        if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) return { value: value1 };
        if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {
          for (const key in value2) if (key in value1) {
            const dataset = _merge(value1[key], value2[key]);
            if (dataset.issue) return dataset;
            value1[key] = dataset.value;
          } else value1[key] = value2[key];
          return { value: value1 };
        }
        if (Array.isArray(value1) && Array.isArray(value2)) {
          if (value1.length === value2.length) {
            for (let index = 0; index < value1.length; index++) {
              const dataset = _merge(value1[index], value2[index]);
              if (dataset.issue) return dataset;
              value1[index] = dataset.value;
            }
            return { value: value1 };
          }
        }
      }
      return { issue: true };
    }
    function intersect(options, message$1) {
      return {
        kind: "schema",
        type: "intersect",
        reference: intersect,
        expects: _joinExpects(options.map((option) => option.expects), "&"),
        async: false,
        options,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (this.options.length) {
            const input = dataset.value;
            let outputs;
            dataset.typed = true;
            for (const schema of this.options) {
              const optionDataset = schema["~run"]({ value: input }, config$1);
              if (optionDataset.issues) {
                if (dataset.issues) dataset.issues.push(...optionDataset.issues);
                else dataset.issues = optionDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!optionDataset.typed) dataset.typed = false;
              if (dataset.typed) if (outputs) outputs.push(optionDataset.value);
              else outputs = [optionDataset.value];
            }
            if (dataset.typed) {
              dataset.value = outputs[0];
              for (let index = 1; index < outputs.length; index++) {
                const mergeDataset = _merge(dataset.value, outputs[index]);
                if (mergeDataset.issue) {
                  _addIssue(this, "type", dataset, config$1, { received: "unknown" });
                  break;
                }
                dataset.value = mergeDataset.value;
              }
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function intersectAsync(options, message$1) {
      return {
        kind: "schema",
        type: "intersect",
        reference: intersectAsync,
        expects: _joinExpects(options.map((option) => option.expects), "&"),
        async: true,
        options,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          if (this.options.length) {
            const input = dataset.value;
            let outputs;
            dataset.typed = true;
            const optionDatasets = await Promise.all(this.options.map((schema) => schema["~run"]({ value: input }, config$1)));
            for (const optionDataset of optionDatasets) {
              if (optionDataset.issues) {
                if (dataset.issues) dataset.issues.push(...optionDataset.issues);
                else dataset.issues = optionDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!optionDataset.typed) dataset.typed = false;
              if (dataset.typed) if (outputs) outputs.push(optionDataset.value);
              else outputs = [optionDataset.value];
            }
            if (dataset.typed) {
              dataset.value = outputs[0];
              for (let index = 1; index < outputs.length; index++) {
                const mergeDataset = _merge(dataset.value, outputs[index]);
                if (mergeDataset.issue) {
                  _addIssue(this, "type", dataset, config$1, { received: "unknown" });
                  break;
                }
                dataset.value = mergeDataset.value;
              }
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function lazy(getter) {
      return {
        kind: "schema",
        type: "lazy",
        reference: lazy,
        expects: "unknown",
        async: false,
        getter,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          return this.getter(dataset.value)["~run"](dataset, config$1);
        }
      };
    }
    function lazyAsync(getter) {
      return {
        kind: "schema",
        type: "lazy",
        reference: lazyAsync,
        expects: "unknown",
        async: true,
        getter,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          return (await this.getter(dataset.value))["~run"](dataset, config$1);
        }
      };
    }
    function literal(literal_, message$1) {
      return {
        kind: "schema",
        type: "literal",
        reference: literal,
        expects: _stringify(literal_),
        async: false,
        literal: literal_,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value === this.literal) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function looseObject(entries$1, message$1) {
      return {
        kind: "schema",
        type: "loose_object",
        reference: looseObject,
        expects: "Object",
        async: false,
        entries: entries$1,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (input && typeof input === "object") {
            dataset.typed = true;
            dataset.value = {};
            for (const key in this.entries) {
              const valueSchema = this.entries[key];
              if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                const value$1 = key in input ? input[key] : getDefault(valueSchema);
                const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "value",
                    input,
                    key,
                    value: value$1
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) issue.path.unshift(pathItem);
                    else issue.path = [pathItem];
                    (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                  }
                  if (!dataset.issues) dataset.issues = valueDataset.issues;
                  if (config$1.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) dataset.typed = false;
                dataset.value[key] = valueDataset.value;
              } else if (valueSchema.fallback !== void 0) dataset.value[key] = getFallback(valueSchema);
              else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                _addIssue(this, "key", dataset, config$1, {
                  input: void 0,
                  expected: `"${key}"`,
                  path: [{
                    type: "object",
                    origin: "key",
                    input,
                    key,
                    value: input[key]
                  }]
                });
                if (config$1.abortEarly) break;
              }
            }
            if (!dataset.issues || !config$1.abortEarly) {
              for (const key in input) if (_isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function looseObjectAsync(entries$1, message$1) {
      return {
        kind: "schema",
        type: "loose_object",
        reference: looseObjectAsync,
        expects: "Object",
        async: true,
        entries: entries$1,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (input && typeof input === "object") {
            dataset.typed = true;
            dataset.value = {};
            const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {
              if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                const value$1 = key in input ? input[key] : await getDefault(valueSchema);
                return [
                  key,
                  value$1,
                  valueSchema,
                  await valueSchema["~run"]({ value: value$1 }, config$1)
                ];
              }
              return [
                key,
                input[key],
                valueSchema,
                null
              ];
            }));
            for (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {
              if (valueDataset.issues) {
                const pathItem = {
                  type: "object",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of valueDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = valueDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!valueDataset.typed) dataset.typed = false;
              dataset.value[key] = valueDataset.value;
            } else if (valueSchema.fallback !== void 0) dataset.value[key] = await getFallback(valueSchema);
            else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
              _addIssue(this, "key", dataset, config$1, {
                input: void 0,
                expected: `"${key}"`,
                path: [{
                  type: "object",
                  origin: "key",
                  input,
                  key,
                  value: value$1
                }]
              });
              if (config$1.abortEarly) break;
            }
            if (!dataset.issues || !config$1.abortEarly) {
              for (const key in input) if (_isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function looseTuple(items, message$1) {
      return {
        kind: "schema",
        type: "loose_tuple",
        reference: looseTuple,
        expects: "Array",
        async: false,
        items,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (Array.isArray(input)) {
            dataset.typed = true;
            dataset.value = [];
            for (let key = 0; key < this.items.length; key++) {
              const value$1 = input[key];
              const itemDataset = this.items[key]["~run"]({ value: value$1 }, config$1);
              if (itemDataset.issues) {
                const pathItem = {
                  type: "array",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of itemDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = itemDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!itemDataset.typed) dataset.typed = false;
              dataset.value.push(itemDataset.value);
            }
            if (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function looseTupleAsync(items, message$1) {
      return {
        kind: "schema",
        type: "loose_tuple",
        reference: looseTupleAsync,
        expects: "Array",
        async: true,
        items,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (Array.isArray(input)) {
            dataset.typed = true;
            dataset.value = [];
            const itemDatasets = await Promise.all(this.items.map(async (item, key) => {
              const value$1 = input[key];
              return [
                key,
                value$1,
                await item["~run"]({ value: value$1 }, config$1)
              ];
            }));
            for (const [key, value$1, itemDataset] of itemDatasets) {
              if (itemDataset.issues) {
                const pathItem = {
                  type: "array",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of itemDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = itemDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!itemDataset.typed) dataset.typed = false;
              dataset.value.push(itemDataset.value);
            }
            if (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function map(key, value$1, message$1) {
      return {
        kind: "schema",
        type: "map",
        reference: map,
        expects: "Map",
        async: false,
        key,
        value: value$1,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          var _a, _b;
          const input = dataset.value;
          if (input instanceof Map) {
            dataset.typed = true;
            dataset.value = /* @__PURE__ */ new Map();
            for (const [inputKey, inputValue] of input) {
              const keyDataset = this.key["~run"]({ value: inputKey }, config$1);
              if (keyDataset.issues) {
                const pathItem = {
                  type: "map",
                  origin: "key",
                  input,
                  key: inputKey,
                  value: inputValue
                };
                for (const issue of keyDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = keyDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              const valueDataset = this.value["~run"]({ value: inputValue }, config$1);
              if (valueDataset.issues) {
                const pathItem = {
                  type: "map",
                  origin: "value",
                  input,
                  key: inputKey,
                  value: inputValue
                };
                for (const issue of valueDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_b = dataset.issues) == null ? void 0 : _b.push(issue);
                }
                if (!dataset.issues) dataset.issues = valueDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
              dataset.value.set(keyDataset.value, valueDataset.value);
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function mapAsync(key, value$1, message$1) {
      return {
        kind: "schema",
        type: "map",
        reference: mapAsync,
        expects: "Map",
        async: true,
        key,
        value: value$1,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          var _a, _b;
          const input = dataset.value;
          if (input instanceof Map) {
            dataset.typed = true;
            dataset.value = /* @__PURE__ */ new Map();
            const datasets = await Promise.all([...input].map(([inputKey, inputValue]) => Promise.all([
              inputKey,
              inputValue,
              this.key["~run"]({ value: inputKey }, config$1),
              this.value["~run"]({ value: inputValue }, config$1)
            ])));
            for (const [inputKey, inputValue, keyDataset, valueDataset] of datasets) {
              if (keyDataset.issues) {
                const pathItem = {
                  type: "map",
                  origin: "key",
                  input,
                  key: inputKey,
                  value: inputValue
                };
                for (const issue of keyDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = keyDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (valueDataset.issues) {
                const pathItem = {
                  type: "map",
                  origin: "value",
                  input,
                  key: inputKey,
                  value: inputValue
                };
                for (const issue of valueDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_b = dataset.issues) == null ? void 0 : _b.push(issue);
                }
                if (!dataset.issues) dataset.issues = valueDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
              dataset.value.set(keyDataset.value, valueDataset.value);
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function nan(message$1) {
      return {
        kind: "schema",
        type: "nan",
        reference: nan,
        expects: "NaN",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (Number.isNaN(dataset.value)) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function never(message$1) {
      return {
        kind: "schema",
        type: "never",
        reference: never,
        expects: "never",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function nonNullable(wrapped, message$1) {
      return {
        kind: "schema",
        type: "non_nullable",
        reference: nonNullable,
        expects: "!null",
        async: false,
        wrapped,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value !== null) dataset = this.wrapped["~run"](dataset, config$1);
          if (dataset.value === null) _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function nonNullableAsync(wrapped, message$1) {
      return {
        kind: "schema",
        type: "non_nullable",
        reference: nonNullableAsync,
        expects: "!null",
        async: true,
        wrapped,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          if (dataset.value !== null) dataset = await this.wrapped["~run"](dataset, config$1);
          if (dataset.value === null) _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function nonNullish(wrapped, message$1) {
      return {
        kind: "schema",
        type: "non_nullish",
        reference: nonNullish,
        expects: "(!null & !undefined)",
        async: false,
        wrapped,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (!(dataset.value === null || dataset.value === void 0)) dataset = this.wrapped["~run"](dataset, config$1);
          if (dataset.value === null || dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function nonNullishAsync(wrapped, message$1) {
      return {
        kind: "schema",
        type: "non_nullish",
        reference: nonNullishAsync,
        expects: "(!null & !undefined)",
        async: true,
        wrapped,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          if (!(dataset.value === null || dataset.value === void 0)) dataset = await this.wrapped["~run"](dataset, config$1);
          if (dataset.value === null || dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function nonOptional(wrapped, message$1) {
      return {
        kind: "schema",
        type: "non_optional",
        reference: nonOptional,
        expects: "!undefined",
        async: false,
        wrapped,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value !== void 0) dataset = this.wrapped["~run"](dataset, config$1);
          if (dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function nonOptionalAsync(wrapped, message$1) {
      return {
        kind: "schema",
        type: "non_optional",
        reference: nonOptionalAsync,
        expects: "!undefined",
        async: true,
        wrapped,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          if (dataset.value !== void 0) dataset = await this.wrapped["~run"](dataset, config$1);
          if (dataset.value === void 0) _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function null_(message$1) {
      return {
        kind: "schema",
        type: "null",
        reference: null_,
        expects: "null",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value === null) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function nullable(wrapped, default_) {
      return {
        kind: "schema",
        type: "nullable",
        reference: nullable,
        expects: `(${wrapped.expects} | null)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value === null) {
            if (this.default !== void 0) dataset.value = getDefault(this, dataset, config$1);
            if (dataset.value === null) {
              dataset.typed = true;
              return dataset;
            }
          }
          return this.wrapped["~run"](dataset, config$1);
        }
      };
    }
    function nullableAsync(wrapped, default_) {
      return {
        kind: "schema",
        type: "nullable",
        reference: nullableAsync,
        expects: `(${wrapped.expects} | null)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          if (dataset.value === null) {
            if (this.default !== void 0) dataset.value = await getDefault(this, dataset, config$1);
            if (dataset.value === null) {
              dataset.typed = true;
              return dataset;
            }
          }
          return this.wrapped["~run"](dataset, config$1);
        }
      };
    }
    function nullish(wrapped, default_) {
      return {
        kind: "schema",
        type: "nullish",
        reference: nullish,
        expects: `(${wrapped.expects} | null | undefined)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value === null || dataset.value === void 0) {
            if (this.default !== void 0) dataset.value = getDefault(this, dataset, config$1);
            if (dataset.value === null || dataset.value === void 0) {
              dataset.typed = true;
              return dataset;
            }
          }
          return this.wrapped["~run"](dataset, config$1);
        }
      };
    }
    function nullishAsync(wrapped, default_) {
      return {
        kind: "schema",
        type: "nullish",
        reference: nullishAsync,
        expects: `(${wrapped.expects} | null | undefined)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          if (dataset.value === null || dataset.value === void 0) {
            if (this.default !== void 0) dataset.value = await getDefault(this, dataset, config$1);
            if (dataset.value === null || dataset.value === void 0) {
              dataset.typed = true;
              return dataset;
            }
          }
          return this.wrapped["~run"](dataset, config$1);
        }
      };
    }
    function number(message$1) {
      return {
        kind: "schema",
        type: "number",
        reference: number,
        expects: "number",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (typeof dataset.value === "number" && !isNaN(dataset.value)) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function object(entries$1, message$1) {
      return {
        kind: "schema",
        type: "object",
        reference: object,
        expects: "Object",
        async: false,
        entries: entries$1,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (input && typeof input === "object") {
            dataset.typed = true;
            dataset.value = {};
            for (const key in this.entries) {
              const valueSchema = this.entries[key];
              if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                const value$1 = key in input ? input[key] : getDefault(valueSchema);
                const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "value",
                    input,
                    key,
                    value: value$1
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) issue.path.unshift(pathItem);
                    else issue.path = [pathItem];
                    (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                  }
                  if (!dataset.issues) dataset.issues = valueDataset.issues;
                  if (config$1.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) dataset.typed = false;
                dataset.value[key] = valueDataset.value;
              } else if (valueSchema.fallback !== void 0) dataset.value[key] = getFallback(valueSchema);
              else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                _addIssue(this, "key", dataset, config$1, {
                  input: void 0,
                  expected: `"${key}"`,
                  path: [{
                    type: "object",
                    origin: "key",
                    input,
                    key,
                    value: input[key]
                  }]
                });
                if (config$1.abortEarly) break;
              }
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function objectAsync(entries$1, message$1) {
      return {
        kind: "schema",
        type: "object",
        reference: objectAsync,
        expects: "Object",
        async: true,
        entries: entries$1,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (input && typeof input === "object") {
            dataset.typed = true;
            dataset.value = {};
            const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {
              if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                const value$1 = key in input ? input[key] : await getDefault(valueSchema);
                return [
                  key,
                  value$1,
                  valueSchema,
                  await valueSchema["~run"]({ value: value$1 }, config$1)
                ];
              }
              return [
                key,
                input[key],
                valueSchema,
                null
              ];
            }));
            for (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {
              if (valueDataset.issues) {
                const pathItem = {
                  type: "object",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of valueDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = valueDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!valueDataset.typed) dataset.typed = false;
              dataset.value[key] = valueDataset.value;
            } else if (valueSchema.fallback !== void 0) dataset.value[key] = await getFallback(valueSchema);
            else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
              _addIssue(this, "key", dataset, config$1, {
                input: void 0,
                expected: `"${key}"`,
                path: [{
                  type: "object",
                  origin: "key",
                  input,
                  key,
                  value: value$1
                }]
              });
              if (config$1.abortEarly) break;
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function objectWithRest(entries$1, rest, message$1) {
      return {
        kind: "schema",
        type: "object_with_rest",
        reference: objectWithRest,
        expects: "Object",
        async: false,
        entries: entries$1,
        rest,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          var _a, _b;
          const input = dataset.value;
          if (input && typeof input === "object") {
            dataset.typed = true;
            dataset.value = {};
            for (const key in this.entries) {
              const valueSchema = this.entries[key];
              if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                const value$1 = key in input ? input[key] : getDefault(valueSchema);
                const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "value",
                    input,
                    key,
                    value: value$1
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) issue.path.unshift(pathItem);
                    else issue.path = [pathItem];
                    (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                  }
                  if (!dataset.issues) dataset.issues = valueDataset.issues;
                  if (config$1.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) dataset.typed = false;
                dataset.value[key] = valueDataset.value;
              } else if (valueSchema.fallback !== void 0) dataset.value[key] = getFallback(valueSchema);
              else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                _addIssue(this, "key", dataset, config$1, {
                  input: void 0,
                  expected: `"${key}"`,
                  path: [{
                    type: "object",
                    origin: "key",
                    input,
                    key,
                    value: input[key]
                  }]
                });
                if (config$1.abortEarly) break;
              }
            }
            if (!dataset.issues || !config$1.abortEarly) {
              for (const key in input) if (_isValidObjectKey(input, key) && !(key in this.entries)) {
                const valueDataset = this.rest["~run"]({ value: input[key] }, config$1);
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "value",
                    input,
                    key,
                    value: input[key]
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) issue.path.unshift(pathItem);
                    else issue.path = [pathItem];
                    (_b = dataset.issues) == null ? void 0 : _b.push(issue);
                  }
                  if (!dataset.issues) dataset.issues = valueDataset.issues;
                  if (config$1.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) dataset.typed = false;
                dataset.value[key] = valueDataset.value;
              }
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function objectWithRestAsync(entries$1, rest, message$1) {
      return {
        kind: "schema",
        type: "object_with_rest",
        reference: objectWithRestAsync,
        expects: "Object",
        async: true,
        entries: entries$1,
        rest,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          var _a, _b;
          const input = dataset.value;
          if (input && typeof input === "object") {
            dataset.typed = true;
            dataset.value = {};
            const [normalDatasets, restDatasets] = await Promise.all([Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {
              if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                const value$1 = key in input ? input[key] : await getDefault(valueSchema);
                return [
                  key,
                  value$1,
                  valueSchema,
                  await valueSchema["~run"]({ value: value$1 }, config$1)
                ];
              }
              return [
                key,
                input[key],
                valueSchema,
                null
              ];
            })), Promise.all(Object.entries(input).filter(([key]) => _isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value$1]) => [
              key,
              value$1,
              await this.rest["~run"]({ value: value$1 }, config$1)
            ]))]);
            for (const [key, value$1, valueSchema, valueDataset] of normalDatasets) if (valueDataset) {
              if (valueDataset.issues) {
                const pathItem = {
                  type: "object",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of valueDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = valueDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!valueDataset.typed) dataset.typed = false;
              dataset.value[key] = valueDataset.value;
            } else if (valueSchema.fallback !== void 0) dataset.value[key] = await getFallback(valueSchema);
            else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
              _addIssue(this, "key", dataset, config$1, {
                input: void 0,
                expected: `"${key}"`,
                path: [{
                  type: "object",
                  origin: "key",
                  input,
                  key,
                  value: value$1
                }]
              });
              if (config$1.abortEarly) break;
            }
            if (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, valueDataset] of restDatasets) {
              if (valueDataset.issues) {
                const pathItem = {
                  type: "object",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of valueDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_b = dataset.issues) == null ? void 0 : _b.push(issue);
                }
                if (!dataset.issues) dataset.issues = valueDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!valueDataset.typed) dataset.typed = false;
              dataset.value[key] = valueDataset.value;
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function optional(wrapped, default_) {
      return {
        kind: "schema",
        type: "optional",
        reference: optional,
        expects: `(${wrapped.expects} | undefined)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value === void 0) {
            if (this.default !== void 0) dataset.value = getDefault(this, dataset, config$1);
            if (dataset.value === void 0) {
              dataset.typed = true;
              return dataset;
            }
          }
          return this.wrapped["~run"](dataset, config$1);
        }
      };
    }
    function optionalAsync(wrapped, default_) {
      return {
        kind: "schema",
        type: "optional",
        reference: optionalAsync,
        expects: `(${wrapped.expects} | undefined)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          if (dataset.value === void 0) {
            if (this.default !== void 0) dataset.value = await getDefault(this, dataset, config$1);
            if (dataset.value === void 0) {
              dataset.typed = true;
              return dataset;
            }
          }
          return this.wrapped["~run"](dataset, config$1);
        }
      };
    }
    function picklist(options, message$1) {
      return {
        kind: "schema",
        type: "picklist",
        reference: picklist,
        expects: _joinExpects(options.map(_stringify), "|"),
        async: false,
        options,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (this.options.includes(dataset.value)) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function promise(message$1) {
      return {
        kind: "schema",
        type: "promise",
        reference: promise,
        expects: "Promise",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value instanceof Promise) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function record(key, value$1, message$1) {
      return {
        kind: "schema",
        type: "record",
        reference: record,
        expects: "Object",
        async: false,
        key,
        value: value$1,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          var _a, _b;
          const input = dataset.value;
          if (input && typeof input === "object") {
            dataset.typed = true;
            dataset.value = {};
            for (const entryKey in input) if (_isValidObjectKey(input, entryKey)) {
              const entryValue = input[entryKey];
              const keyDataset = this.key["~run"]({ value: entryKey }, config$1);
              if (keyDataset.issues) {
                const pathItem = {
                  type: "object",
                  origin: "key",
                  input,
                  key: entryKey,
                  value: entryValue
                };
                for (const issue of keyDataset.issues) {
                  issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = keyDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              const valueDataset = this.value["~run"]({ value: entryValue }, config$1);
              if (valueDataset.issues) {
                const pathItem = {
                  type: "object",
                  origin: "value",
                  input,
                  key: entryKey,
                  value: entryValue
                };
                for (const issue of valueDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_b = dataset.issues) == null ? void 0 : _b.push(issue);
                }
                if (!dataset.issues) dataset.issues = valueDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
              if (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function recordAsync(key, value$1, message$1) {
      return {
        kind: "schema",
        type: "record",
        reference: recordAsync,
        expects: "Object",
        async: true,
        key,
        value: value$1,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          var _a, _b;
          const input = dataset.value;
          if (input && typeof input === "object") {
            dataset.typed = true;
            dataset.value = {};
            const datasets = await Promise.all(Object.entries(input).filter(([key$1]) => _isValidObjectKey(input, key$1)).map(([entryKey, entryValue]) => Promise.all([
              entryKey,
              entryValue,
              this.key["~run"]({ value: entryKey }, config$1),
              this.value["~run"]({ value: entryValue }, config$1)
            ])));
            for (const [entryKey, entryValue, keyDataset, valueDataset] of datasets) {
              if (keyDataset.issues) {
                const pathItem = {
                  type: "object",
                  origin: "key",
                  input,
                  key: entryKey,
                  value: entryValue
                };
                for (const issue of keyDataset.issues) {
                  issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = keyDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (valueDataset.issues) {
                const pathItem = {
                  type: "object",
                  origin: "value",
                  input,
                  key: entryKey,
                  value: entryValue
                };
                for (const issue of valueDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_b = dataset.issues) == null ? void 0 : _b.push(issue);
                }
                if (!dataset.issues) dataset.issues = valueDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;
              if (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function set(value$1, message$1) {
      return {
        kind: "schema",
        type: "set",
        reference: set,
        expects: "Set",
        async: false,
        value: value$1,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (input instanceof Set) {
            dataset.typed = true;
            dataset.value = /* @__PURE__ */ new Set();
            for (const inputValue of input) {
              const valueDataset = this.value["~run"]({ value: inputValue }, config$1);
              if (valueDataset.issues) {
                const pathItem = {
                  type: "set",
                  origin: "value",
                  input,
                  key: null,
                  value: inputValue
                };
                for (const issue of valueDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = valueDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!valueDataset.typed) dataset.typed = false;
              dataset.value.add(valueDataset.value);
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function setAsync(value$1, message$1) {
      return {
        kind: "schema",
        type: "set",
        reference: setAsync,
        expects: "Set",
        async: true,
        value: value$1,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (input instanceof Set) {
            dataset.typed = true;
            dataset.value = /* @__PURE__ */ new Set();
            const valueDatasets = await Promise.all([...input].map(async (inputValue) => [inputValue, await this.value["~run"]({ value: inputValue }, config$1)]));
            for (const [inputValue, valueDataset] of valueDatasets) {
              if (valueDataset.issues) {
                const pathItem = {
                  type: "set",
                  origin: "value",
                  input,
                  key: null,
                  value: inputValue
                };
                for (const issue of valueDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = valueDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!valueDataset.typed) dataset.typed = false;
              dataset.value.add(valueDataset.value);
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function strictObject(entries$1, message$1) {
      return {
        kind: "schema",
        type: "strict_object",
        reference: strictObject,
        expects: "Object",
        async: false,
        entries: entries$1,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (input && typeof input === "object") {
            dataset.typed = true;
            dataset.value = {};
            for (const key in this.entries) {
              const valueSchema = this.entries[key];
              if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                const value$1 = key in input ? input[key] : getDefault(valueSchema);
                const valueDataset = valueSchema["~run"]({ value: value$1 }, config$1);
                if (valueDataset.issues) {
                  const pathItem = {
                    type: "object",
                    origin: "value",
                    input,
                    key,
                    value: value$1
                  };
                  for (const issue of valueDataset.issues) {
                    if (issue.path) issue.path.unshift(pathItem);
                    else issue.path = [pathItem];
                    (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                  }
                  if (!dataset.issues) dataset.issues = valueDataset.issues;
                  if (config$1.abortEarly) {
                    dataset.typed = false;
                    break;
                  }
                }
                if (!valueDataset.typed) dataset.typed = false;
                dataset.value[key] = valueDataset.value;
              } else if (valueSchema.fallback !== void 0) dataset.value[key] = getFallback(valueSchema);
              else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
                _addIssue(this, "key", dataset, config$1, {
                  input: void 0,
                  expected: `"${key}"`,
                  path: [{
                    type: "object",
                    origin: "key",
                    input,
                    key,
                    value: input[key]
                  }]
                });
                if (config$1.abortEarly) break;
              }
            }
            if (!dataset.issues || !config$1.abortEarly) {
              for (const key in input) if (!(key in this.entries)) {
                _addIssue(this, "key", dataset, config$1, {
                  input: key,
                  expected: "never",
                  path: [{
                    type: "object",
                    origin: "key",
                    input,
                    key,
                    value: input[key]
                  }]
                });
                break;
              }
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function strictObjectAsync(entries$1, message$1) {
      return {
        kind: "schema",
        type: "strict_object",
        reference: strictObjectAsync,
        expects: "Object",
        async: true,
        entries: entries$1,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (input && typeof input === "object") {
            dataset.typed = true;
            dataset.value = {};
            const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {
              if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && valueSchema.default !== void 0) {
                const value$1 = key in input ? input[key] : await getDefault(valueSchema);
                return [
                  key,
                  value$1,
                  valueSchema,
                  await valueSchema["~run"]({ value: value$1 }, config$1)
                ];
              }
              return [
                key,
                input[key],
                valueSchema,
                null
              ];
            }));
            for (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {
              if (valueDataset.issues) {
                const pathItem = {
                  type: "object",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of valueDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = valueDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!valueDataset.typed) dataset.typed = false;
              dataset.value[key] = valueDataset.value;
            } else if (valueSchema.fallback !== void 0) dataset.value[key] = await getFallback(valueSchema);
            else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
              _addIssue(this, "key", dataset, config$1, {
                input: void 0,
                expected: `"${key}"`,
                path: [{
                  type: "object",
                  origin: "key",
                  input,
                  key,
                  value: value$1
                }]
              });
              if (config$1.abortEarly) break;
            }
            if (!dataset.issues || !config$1.abortEarly) {
              for (const key in input) if (!(key in this.entries)) {
                _addIssue(this, "key", dataset, config$1, {
                  input: key,
                  expected: "never",
                  path: [{
                    type: "object",
                    origin: "key",
                    input,
                    key,
                    value: input[key]
                  }]
                });
                break;
              }
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function strictTuple(items, message$1) {
      return {
        kind: "schema",
        type: "strict_tuple",
        reference: strictTuple,
        expects: "Array",
        async: false,
        items,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (Array.isArray(input)) {
            dataset.typed = true;
            dataset.value = [];
            for (let key = 0; key < this.items.length; key++) {
              const value$1 = input[key];
              const itemDataset = this.items[key]["~run"]({ value: value$1 }, config$1);
              if (itemDataset.issues) {
                const pathItem = {
                  type: "array",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of itemDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = itemDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!itemDataset.typed) dataset.typed = false;
              dataset.value.push(itemDataset.value);
            }
            if (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, "type", dataset, config$1, {
              input: input[this.items.length],
              expected: "never",
              path: [{
                type: "array",
                origin: "value",
                input,
                key: this.items.length,
                value: input[this.items.length]
              }]
            });
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function strictTupleAsync(items, message$1) {
      return {
        kind: "schema",
        type: "strict_tuple",
        reference: strictTupleAsync,
        expects: "Array",
        async: true,
        items,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (Array.isArray(input)) {
            dataset.typed = true;
            dataset.value = [];
            const itemDatasets = await Promise.all(this.items.map(async (item, key) => {
              const value$1 = input[key];
              return [
                key,
                value$1,
                await item["~run"]({ value: value$1 }, config$1)
              ];
            }));
            for (const [key, value$1, itemDataset] of itemDatasets) {
              if (itemDataset.issues) {
                const pathItem = {
                  type: "array",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of itemDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = itemDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!itemDataset.typed) dataset.typed = false;
              dataset.value.push(itemDataset.value);
            }
            if (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, "type", dataset, config$1, {
              input: input[this.items.length],
              expected: "never",
              path: [{
                type: "array",
                origin: "value",
                input,
                key: this.items.length,
                value: input[this.items.length]
              }]
            });
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function string(message$1) {
      return {
        kind: "schema",
        type: "string",
        reference: string,
        expects: "string",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (typeof dataset.value === "string") dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function symbol(message$1) {
      return {
        kind: "schema",
        type: "symbol",
        reference: symbol,
        expects: "symbol",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (typeof dataset.value === "symbol") dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function tuple(items, message$1) {
      return {
        kind: "schema",
        type: "tuple",
        reference: tuple,
        expects: "Array",
        async: false,
        items,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (Array.isArray(input)) {
            dataset.typed = true;
            dataset.value = [];
            for (let key = 0; key < this.items.length; key++) {
              const value$1 = input[key];
              const itemDataset = this.items[key]["~run"]({ value: value$1 }, config$1);
              if (itemDataset.issues) {
                const pathItem = {
                  type: "array",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of itemDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = itemDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!itemDataset.typed) dataset.typed = false;
              dataset.value.push(itemDataset.value);
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function tupleAsync(items, message$1) {
      return {
        kind: "schema",
        type: "tuple",
        reference: tupleAsync,
        expects: "Array",
        async: true,
        items,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          var _a;
          const input = dataset.value;
          if (Array.isArray(input)) {
            dataset.typed = true;
            dataset.value = [];
            const itemDatasets = await Promise.all(this.items.map(async (item, key) => {
              const value$1 = input[key];
              return [
                key,
                value$1,
                await item["~run"]({ value: value$1 }, config$1)
              ];
            }));
            for (const [key, value$1, itemDataset] of itemDatasets) {
              if (itemDataset.issues) {
                const pathItem = {
                  type: "array",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of itemDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = itemDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!itemDataset.typed) dataset.typed = false;
              dataset.value.push(itemDataset.value);
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function tupleWithRest(items, rest, message$1) {
      return {
        kind: "schema",
        type: "tuple_with_rest",
        reference: tupleWithRest,
        expects: "Array",
        async: false,
        items,
        rest,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          var _a, _b;
          const input = dataset.value;
          if (Array.isArray(input)) {
            dataset.typed = true;
            dataset.value = [];
            for (let key = 0; key < this.items.length; key++) {
              const value$1 = input[key];
              const itemDataset = this.items[key]["~run"]({ value: value$1 }, config$1);
              if (itemDataset.issues) {
                const pathItem = {
                  type: "array",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of itemDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = itemDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!itemDataset.typed) dataset.typed = false;
              dataset.value.push(itemDataset.value);
            }
            if (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) {
              const value$1 = input[key];
              const itemDataset = this.rest["~run"]({ value: value$1 }, config$1);
              if (itemDataset.issues) {
                const pathItem = {
                  type: "array",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of itemDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_b = dataset.issues) == null ? void 0 : _b.push(issue);
                }
                if (!dataset.issues) dataset.issues = itemDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!itemDataset.typed) dataset.typed = false;
              dataset.value.push(itemDataset.value);
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function tupleWithRestAsync(items, rest, message$1) {
      return {
        kind: "schema",
        type: "tuple_with_rest",
        reference: tupleWithRestAsync,
        expects: "Array",
        async: true,
        items,
        rest,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          var _a, _b;
          const input = dataset.value;
          if (Array.isArray(input)) {
            dataset.typed = true;
            dataset.value = [];
            const [normalDatasets, restDatasets] = await Promise.all([Promise.all(this.items.map(async (item, key) => {
              const value$1 = input[key];
              return [
                key,
                value$1,
                await item["~run"]({ value: value$1 }, config$1)
              ];
            })), Promise.all(input.slice(this.items.length).map(async (value$1, key) => {
              return [
                key + this.items.length,
                value$1,
                await this.rest["~run"]({ value: value$1 }, config$1)
              ];
            }))]);
            for (const [key, value$1, itemDataset] of normalDatasets) {
              if (itemDataset.issues) {
                const pathItem = {
                  type: "array",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of itemDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_a = dataset.issues) == null ? void 0 : _a.push(issue);
                }
                if (!dataset.issues) dataset.issues = itemDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!itemDataset.typed) dataset.typed = false;
              dataset.value.push(itemDataset.value);
            }
            if (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, itemDataset] of restDatasets) {
              if (itemDataset.issues) {
                const pathItem = {
                  type: "array",
                  origin: "value",
                  input,
                  key,
                  value: value$1
                };
                for (const issue of itemDataset.issues) {
                  if (issue.path) issue.path.unshift(pathItem);
                  else issue.path = [pathItem];
                  (_b = dataset.issues) == null ? void 0 : _b.push(issue);
                }
                if (!dataset.issues) dataset.issues = itemDataset.issues;
                if (config$1.abortEarly) {
                  dataset.typed = false;
                  break;
                }
              }
              if (!itemDataset.typed) dataset.typed = false;
              dataset.value.push(itemDataset.value);
            }
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function undefined_(message$1) {
      return {
        kind: "schema",
        type: "undefined",
        reference: undefined_,
        expects: "undefined",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value === void 0) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function undefinedable(wrapped, default_) {
      return {
        kind: "schema",
        type: "undefinedable",
        reference: undefinedable,
        expects: `(${wrapped.expects} | undefined)`,
        async: false,
        wrapped,
        default: default_,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value === void 0) {
            if (this.default !== void 0) dataset.value = getDefault(this, dataset, config$1);
            if (dataset.value === void 0) {
              dataset.typed = true;
              return dataset;
            }
          }
          return this.wrapped["~run"](dataset, config$1);
        }
      };
    }
    function undefinedableAsync(wrapped, default_) {
      return {
        kind: "schema",
        type: "undefinedable",
        reference: undefinedableAsync,
        expects: `(${wrapped.expects} | undefined)`,
        async: true,
        wrapped,
        default: default_,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          if (dataset.value === void 0) {
            if (this.default !== void 0) dataset.value = await getDefault(this, dataset, config$1);
            if (dataset.value === void 0) {
              dataset.typed = true;
              return dataset;
            }
          }
          return this.wrapped["~run"](dataset, config$1);
        }
      };
    }
    function _subIssues(datasets) {
      let issues;
      if (datasets) for (const dataset of datasets) if (issues) issues.push(...dataset.issues);
      else issues = dataset.issues;
      return issues;
    }
    function union(options, message$1) {
      return {
        kind: "schema",
        type: "union",
        reference: union,
        expects: _joinExpects(options.map((option) => option.expects), "|"),
        async: false,
        options,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          let validDataset;
          let typedDatasets;
          let untypedDatasets;
          for (const schema of this.options) {
            const optionDataset = schema["~run"]({ value: dataset.value }, config$1);
            if (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);
            else typedDatasets = [optionDataset];
            else {
              validDataset = optionDataset;
              break;
            }
            else if (untypedDatasets) untypedDatasets.push(optionDataset);
            else untypedDatasets = [optionDataset];
          }
          if (validDataset) return validDataset;
          if (typedDatasets) {
            if (typedDatasets.length === 1) return typedDatasets[0];
            _addIssue(this, "type", dataset, config$1, { issues: _subIssues(typedDatasets) });
            dataset.typed = true;
          } else if ((untypedDatasets == null ? void 0 : untypedDatasets.length) === 1) return untypedDatasets[0];
          else _addIssue(this, "type", dataset, config$1, { issues: _subIssues(untypedDatasets) });
          return dataset;
        }
      };
    }
    function unionAsync(options, message$1) {
      return {
        kind: "schema",
        type: "union",
        reference: unionAsync,
        expects: _joinExpects(options.map((option) => option.expects), "|"),
        async: true,
        options,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          let validDataset;
          let typedDatasets;
          let untypedDatasets;
          for (const schema of this.options) {
            const optionDataset = await schema["~run"]({ value: dataset.value }, config$1);
            if (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);
            else typedDatasets = [optionDataset];
            else {
              validDataset = optionDataset;
              break;
            }
            else if (untypedDatasets) untypedDatasets.push(optionDataset);
            else untypedDatasets = [optionDataset];
          }
          if (validDataset) return validDataset;
          if (typedDatasets) {
            if (typedDatasets.length === 1) return typedDatasets[0];
            _addIssue(this, "type", dataset, config$1, { issues: _subIssues(typedDatasets) });
            dataset.typed = true;
          } else if ((untypedDatasets == null ? void 0 : untypedDatasets.length) === 1) return untypedDatasets[0];
          else _addIssue(this, "type", dataset, config$1, { issues: _subIssues(untypedDatasets) });
          return dataset;
        }
      };
    }
    function unknown() {
      return {
        kind: "schema",
        type: "unknown",
        reference: unknown,
        expects: "unknown",
        async: false,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset) {
          dataset.typed = true;
          return dataset;
        }
      };
    }
    function variant(key, options, message$1) {
      return {
        kind: "schema",
        type: "variant",
        reference: variant,
        expects: "Object",
        async: false,
        key,
        options,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          const input = dataset.value;
          if (input && typeof input === "object") {
            let outputDataset;
            let maxDiscriminatorPriority = 0;
            let invalidDiscriminatorKey = this.key;
            let expectedDiscriminators = [];
            const parseOptions = (variant$1, allKeys) => {
              for (const schema of variant$1.options) {
                if (schema.type === "variant") parseOptions(schema, new Set(allKeys).add(schema.key));
                else {
                  let keysAreValid = true;
                  let currentPriority = 0;
                  for (const currentKey of allKeys) {
                    const discriminatorSchema = schema.entries[currentKey];
                    if (currentKey in input ? discriminatorSchema["~run"]({
                      typed: false,
                      value: input[currentKey]
                    }, { abortEarly: true }).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
                      keysAreValid = false;
                      if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
                        maxDiscriminatorPriority = currentPriority;
                        invalidDiscriminatorKey = currentKey;
                        expectedDiscriminators = [];
                      }
                      if (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);
                      break;
                    }
                    currentPriority++;
                  }
                  if (keysAreValid) {
                    const optionDataset = schema["~run"]({ value: input }, config$1);
                    if (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;
                  }
                }
                if (outputDataset && !outputDataset.issues) break;
              }
            };
            parseOptions(this, /* @__PURE__ */ new Set([this.key]));
            if (outputDataset) return outputDataset;
            _addIssue(this, "type", dataset, config$1, {
              input: input[invalidDiscriminatorKey],
              expected: _joinExpects(expectedDiscriminators, "|"),
              path: [{
                type: "object",
                origin: "value",
                input,
                key: invalidDiscriminatorKey,
                value: input[invalidDiscriminatorKey]
              }]
            });
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function variantAsync(key, options, message$1) {
      return {
        kind: "schema",
        type: "variant",
        reference: variantAsync,
        expects: "Object",
        async: true,
        key,
        options,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          const input = dataset.value;
          if (input && typeof input === "object") {
            let outputDataset;
            let maxDiscriminatorPriority = 0;
            let invalidDiscriminatorKey = this.key;
            let expectedDiscriminators = [];
            const parseOptions = async (variant$1, allKeys) => {
              for (const schema of variant$1.options) {
                if (schema.type === "variant") await parseOptions(schema, new Set(allKeys).add(schema.key));
                else {
                  let keysAreValid = true;
                  let currentPriority = 0;
                  for (const currentKey of allKeys) {
                    const discriminatorSchema = schema.entries[currentKey];
                    if (currentKey in input ? (await discriminatorSchema["~run"]({
                      typed: false,
                      value: input[currentKey]
                    }, { abortEarly: true })).issues : discriminatorSchema.type !== "exact_optional" && discriminatorSchema.type !== "optional" && discriminatorSchema.type !== "nullish") {
                      keysAreValid = false;
                      if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {
                        maxDiscriminatorPriority = currentPriority;
                        invalidDiscriminatorKey = currentKey;
                        expectedDiscriminators = [];
                      }
                      if (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);
                      break;
                    }
                    currentPriority++;
                  }
                  if (keysAreValid) {
                    const optionDataset = await schema["~run"]({ value: input }, config$1);
                    if (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;
                  }
                }
                if (outputDataset && !outputDataset.issues) break;
              }
            };
            await parseOptions(this, /* @__PURE__ */ new Set([this.key]));
            if (outputDataset) return outputDataset;
            _addIssue(this, "type", dataset, config$1, {
              input: input[invalidDiscriminatorKey],
              expected: _joinExpects(expectedDiscriminators, "|"),
              path: [{
                type: "object",
                origin: "value",
                input,
                key: invalidDiscriminatorKey,
                value: input[invalidDiscriminatorKey]
              }]
            });
          } else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function void_(message$1) {
      return {
        kind: "schema",
        type: "void",
        reference: void_,
        expects: "void",
        async: false,
        message: message$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          if (dataset.value === void 0) dataset.typed = true;
          else _addIssue(this, "type", dataset, config$1);
          return dataset;
        }
      };
    }
    function keyof(schema, message$1) {
      return picklist(Object.keys(schema.entries), message$1);
    }
    function message(schema, message_) {
      return {
        ...schema,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          return schema["~run"](dataset, {
            ...config$1,
            message: message_
          });
        }
      };
    }
    function omit(schema, keys) {
      const entries$1 = { ...schema.entries };
      for (const key of keys) delete entries$1[key];
      return {
        ...schema,
        entries: entries$1,
        get "~standard"() {
          return _getStandardProps(this);
        }
      };
    }
    function parse(schema, input, config$1) {
      const dataset = schema["~run"]({ value: input }, getGlobalConfig(config$1));
      if (dataset.issues) throw new ValiError(dataset.issues);
      return dataset.value;
    }
    async function parseAsync(schema, input, config$1) {
      const dataset = await schema["~run"]({ value: input }, getGlobalConfig(config$1));
      if (dataset.issues) throw new ValiError(dataset.issues);
      return dataset.value;
    }
    function parser(schema, config$1) {
      const func = (input) => parse(schema, input, config$1);
      func.schema = schema;
      func.config = config$1;
      return func;
    }
    function parserAsync(schema, config$1) {
      const func = (input) => parseAsync(schema, input, config$1);
      func.schema = schema;
      func.config = config$1;
      return func;
    }
    function partial(schema, keys) {
      const entries$1 = {};
      for (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];
      return {
        ...schema,
        entries: entries$1,
        get "~standard"() {
          return _getStandardProps(this);
        }
      };
    }
    function partialAsync(schema, keys) {
      const entries$1 = {};
      for (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];
      return {
        ...schema,
        entries: entries$1,
        get "~standard"() {
          return _getStandardProps(this);
        }
      };
    }
    function pick2(schema, keys) {
      const entries$1 = {};
      for (const key of keys) entries$1[key] = schema.entries[key];
      return {
        ...schema,
        entries: entries$1,
        get "~standard"() {
          return _getStandardProps(this);
        }
      };
    }
    function pipe(...pipe$1) {
      return {
        ...pipe$1[0],
        pipe: pipe$1,
        get "~standard"() {
          return _getStandardProps(this);
        },
        "~run"(dataset, config$1) {
          for (const item of pipe$1) if (item.kind !== "metadata") {
            if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
              dataset.typed = false;
              break;
            }
            if (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = item["~run"](dataset, config$1);
          }
          return dataset;
        }
      };
    }
    function pipeAsync(...pipe$1) {
      return {
        ...pipe$1[0],
        pipe: pipe$1,
        async: true,
        get "~standard"() {
          return _getStandardProps(this);
        },
        async "~run"(dataset, config$1) {
          for (const item of pipe$1) if (item.kind !== "metadata") {
            if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
              dataset.typed = false;
              break;
            }
            if (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = await item["~run"](dataset, config$1);
          }
          return dataset;
        }
      };
    }
    function required(schema, arg2, arg3) {
      const keys = Array.isArray(arg2) ? arg2 : void 0;
      const message$1 = Array.isArray(arg2) ? arg3 : arg2;
      const entries$1 = {};
      for (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message$1) : schema.entries[key];
      return {
        ...schema,
        entries: entries$1,
        get "~standard"() {
          return _getStandardProps(this);
        }
      };
    }
    function requiredAsync(schema, arg2, arg3) {
      const keys = Array.isArray(arg2) ? arg2 : void 0;
      const message$1 = Array.isArray(arg2) ? arg3 : arg2;
      const entries$1 = {};
      for (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message$1) : schema.entries[key];
      return {
        ...schema,
        entries: entries$1,
        get "~standard"() {
          return _getStandardProps(this);
        }
      };
    }
    function safeParse(schema, input, config$1) {
      const dataset = schema["~run"]({ value: input }, getGlobalConfig(config$1));
      return {
        typed: dataset.typed,
        success: !dataset.issues,
        output: dataset.value,
        issues: dataset.issues
      };
    }
    async function safeParseAsync(schema, input, config$1) {
      const dataset = await schema["~run"]({ value: input }, getGlobalConfig(config$1));
      return {
        typed: dataset.typed,
        success: !dataset.issues,
        output: dataset.value,
        issues: dataset.issues
      };
    }
    function safeParser(schema, config$1) {
      const func = (input) => safeParse(schema, input, config$1);
      func.schema = schema;
      func.config = config$1;
      return func;
    }
    function safeParserAsync(schema, config$1) {
      const func = (input) => safeParseAsync(schema, input, config$1);
      func.schema = schema;
      func.config = config$1;
      return func;
    }
    function summarize(issues) {
      let summary = "";
      for (const issue of issues) {
        if (summary) summary += "\n";
        summary += ` ${issue.message}`;
        const dotPath = getDotPath(issue);
        if (dotPath) summary += `
   at ${dotPath}`;
      }
      return summary;
    }
    function unwrap(schema) {
      return schema.wrapped;
    }
    exports.BASE64_REGEX = BASE64_REGEX;
    exports.BIC_REGEX = BIC_REGEX;
    exports.CUID2_REGEX = CUID2_REGEX;
    exports.DECIMAL_REGEX = DECIMAL_REGEX;
    exports.DIGITS_REGEX = DIGITS_REGEX;
    exports.EMAIL_REGEX = EMAIL_REGEX;
    exports.EMOJI_REGEX = EMOJI_REGEX;
    exports.HEXADECIMAL_REGEX = HEXADECIMAL_REGEX;
    exports.HEX_COLOR_REGEX = HEX_COLOR_REGEX;
    exports.IMEI_REGEX = IMEI_REGEX;
    exports.IPV4_REGEX = IPV4_REGEX;
    exports.IPV6_REGEX = IPV6_REGEX;
    exports.IP_REGEX = IP_REGEX;
    exports.ISO_DATE_REGEX = ISO_DATE_REGEX;
    exports.ISO_DATE_TIME_REGEX = ISO_DATE_TIME_REGEX;
    exports.ISO_TIMESTAMP_REGEX = ISO_TIMESTAMP_REGEX;
    exports.ISO_TIME_REGEX = ISO_TIME_REGEX;
    exports.ISO_TIME_SECOND_REGEX = ISO_TIME_SECOND_REGEX;
    exports.ISO_WEEK_REGEX = ISO_WEEK_REGEX;
    exports.MAC48_REGEX = MAC48_REGEX;
    exports.MAC64_REGEX = MAC64_REGEX;
    exports.MAC_REGEX = MAC_REGEX;
    exports.NANO_ID_REGEX = NANO_ID_REGEX;
    exports.OCTAL_REGEX = OCTAL_REGEX;
    exports.RFC_EMAIL_REGEX = RFC_EMAIL_REGEX;
    exports.SLUG_REGEX = SLUG_REGEX;
    exports.ULID_REGEX = ULID_REGEX;
    exports.UUID_REGEX = UUID_REGEX;
    exports.ValiError = ValiError;
    exports._addIssue = _addIssue;
    exports._getByteCount = _getByteCount;
    exports._getGraphemeCount = _getGraphemeCount;
    exports._getLastMetadata = _getLastMetadata;
    exports._getStandardProps = _getStandardProps;
    exports._getWordCount = _getWordCount;
    exports._isLuhnAlgo = _isLuhnAlgo;
    exports._isValidObjectKey = _isValidObjectKey;
    exports._joinExpects = _joinExpects;
    exports._stringify = _stringify;
    exports.any = any;
    exports.args = args;
    exports.argsAsync = argsAsync;
    exports.array = array;
    exports.arrayAsync = arrayAsync;
    exports.assert = assert;
    exports.awaitAsync = awaitAsync;
    exports.base64 = base64;
    exports.bic = bic;
    exports.bigint = bigint;
    exports.blob = blob;
    exports.boolean = boolean;
    exports.brand = brand;
    exports.bytes = bytes;
    exports.check = check;
    exports.checkAsync = checkAsync;
    exports.checkItems = checkItems;
    exports.checkItemsAsync = checkItemsAsync;
    exports.config = config;
    exports.creditCard = creditCard;
    exports.cuid2 = cuid2;
    exports.custom = custom;
    exports.customAsync = customAsync;
    exports.date = date;
    exports.decimal = decimal;
    exports.deleteGlobalConfig = deleteGlobalConfig;
    exports.deleteGlobalMessage = deleteGlobalMessage;
    exports.deleteSchemaMessage = deleteSchemaMessage;
    exports.deleteSpecificMessage = deleteSpecificMessage;
    exports.description = description;
    exports.digits = digits;
    exports.email = email;
    exports.emoji = emoji;
    exports.empty = empty;
    exports.endsWith = endsWith;
    exports.entries = entries;
    exports.entriesFromList = entriesFromList;
    exports.entriesFromObjects = entriesFromObjects;
    exports.enum = enum_;
    exports.enum_ = enum_;
    exports.everyItem = everyItem;
    exports.exactOptional = exactOptional;
    exports.exactOptionalAsync = exactOptionalAsync;
    exports.examples = examples;
    exports.excludes = excludes;
    exports.fallback = fallback;
    exports.fallbackAsync = fallbackAsync;
    exports.file = file;
    exports.filterItems = filterItems;
    exports.findItem = findItem;
    exports.finite = finite;
    exports.flatten = flatten2;
    exports.flavor = flavor;
    exports.forward = forward;
    exports.forwardAsync = forwardAsync;
    exports.function = function_;
    exports.function_ = function_;
    exports.getDefault = getDefault;
    exports.getDefaults = getDefaults;
    exports.getDefaultsAsync = getDefaultsAsync;
    exports.getDescription = getDescription;
    exports.getDotPath = getDotPath;
    exports.getExamples = getExamples;
    exports.getFallback = getFallback;
    exports.getFallbacks = getFallbacks;
    exports.getFallbacksAsync = getFallbacksAsync;
    exports.getGlobalConfig = getGlobalConfig;
    exports.getGlobalMessage = getGlobalMessage;
    exports.getMetadata = getMetadata;
    exports.getSchemaMessage = getSchemaMessage;
    exports.getSpecificMessage = getSpecificMessage;
    exports.getTitle = getTitle;
    exports.graphemes = graphemes;
    exports.gtValue = gtValue;
    exports.hash = hash;
    exports.hexColor = hexColor;
    exports.hexadecimal = hexadecimal;
    exports.imei = imei;
    exports.includes = includes;
    exports.instance = instance;
    exports.integer = integer;
    exports.intersect = intersect;
    exports.intersectAsync = intersectAsync;
    exports.ip = ip;
    exports.ipv4 = ipv4;
    exports.ipv6 = ipv6;
    exports.is = is;
    exports.isOfKind = isOfKind;
    exports.isOfType = isOfType;
    exports.isValiError = isValiError;
    exports.isoDate = isoDate;
    exports.isoDateTime = isoDateTime;
    exports.isoTime = isoTime;
    exports.isoTimeSecond = isoTimeSecond;
    exports.isoTimestamp = isoTimestamp;
    exports.isoWeek = isoWeek;
    exports.keyof = keyof;
    exports.lazy = lazy;
    exports.lazyAsync = lazyAsync;
    exports.length = length;
    exports.literal = literal;
    exports.looseObject = looseObject;
    exports.looseObjectAsync = looseObjectAsync;
    exports.looseTuple = looseTuple;
    exports.looseTupleAsync = looseTupleAsync;
    exports.ltValue = ltValue;
    exports.mac = mac;
    exports.mac48 = mac48;
    exports.mac64 = mac64;
    exports.map = map;
    exports.mapAsync = mapAsync;
    exports.mapItems = mapItems;
    exports.maxBytes = maxBytes;
    exports.maxEntries = maxEntries;
    exports.maxGraphemes = maxGraphemes;
    exports.maxLength = maxLength;
    exports.maxSize = maxSize;
    exports.maxValue = maxValue;
    exports.maxWords = maxWords;
    exports.message = message;
    exports.metadata = metadata;
    exports.mimeType = mimeType;
    exports.minBytes = minBytes;
    exports.minEntries = minEntries;
    exports.minGraphemes = minGraphemes;
    exports.minLength = minLength;
    exports.minSize = minSize;
    exports.minValue = minValue;
    exports.minWords = minWords;
    exports.multipleOf = multipleOf;
    exports.nan = nan;
    exports.nanoid = nanoid;
    exports.never = never;
    exports.nonEmpty = nonEmpty;
    exports.nonNullable = nonNullable;
    exports.nonNullableAsync = nonNullableAsync;
    exports.nonNullish = nonNullish;
    exports.nonNullishAsync = nonNullishAsync;
    exports.nonOptional = nonOptional;
    exports.nonOptionalAsync = nonOptionalAsync;
    exports.normalize = normalize;
    exports.notBytes = notBytes;
    exports.notEntries = notEntries;
    exports.notGraphemes = notGraphemes;
    exports.notLength = notLength;
    exports.notSize = notSize;
    exports.notValue = notValue;
    exports.notValues = notValues;
    exports.notWords = notWords;
    exports.null = null_;
    exports.null_ = null_;
    exports.nullable = nullable;
    exports.nullableAsync = nullableAsync;
    exports.nullish = nullish;
    exports.nullishAsync = nullishAsync;
    exports.number = number;
    exports.object = object;
    exports.objectAsync = objectAsync;
    exports.objectWithRest = objectWithRest;
    exports.objectWithRestAsync = objectWithRestAsync;
    exports.octal = octal;
    exports.omit = omit;
    exports.optional = optional;
    exports.optionalAsync = optionalAsync;
    exports.parse = parse;
    exports.parseAsync = parseAsync;
    exports.parseJson = parseJson;
    exports.parser = parser;
    exports.parserAsync = parserAsync;
    exports.partial = partial;
    exports.partialAsync = partialAsync;
    exports.partialCheck = partialCheck;
    exports.partialCheckAsync = partialCheckAsync;
    exports.pick = pick2;
    exports.picklist = picklist;
    exports.pipe = pipe;
    exports.pipeAsync = pipeAsync;
    exports.promise = promise;
    exports.rawCheck = rawCheck;
    exports.rawCheckAsync = rawCheckAsync;
    exports.rawTransform = rawTransform;
    exports.rawTransformAsync = rawTransformAsync;
    exports.readonly = readonly;
    exports.record = record;
    exports.recordAsync = recordAsync;
    exports.reduceItems = reduceItems;
    exports.regex = regex;
    exports.required = required;
    exports.requiredAsync = requiredAsync;
    exports.returns = returns;
    exports.returnsAsync = returnsAsync;
    exports.rfcEmail = rfcEmail;
    exports.safeInteger = safeInteger;
    exports.safeParse = safeParse;
    exports.safeParseAsync = safeParseAsync;
    exports.safeParser = safeParser;
    exports.safeParserAsync = safeParserAsync;
    exports.set = set;
    exports.setAsync = setAsync;
    exports.setGlobalConfig = setGlobalConfig;
    exports.setGlobalMessage = setGlobalMessage;
    exports.setSchemaMessage = setSchemaMessage;
    exports.setSpecificMessage = setSpecificMessage;
    exports.size = size;
    exports.slug = slug;
    exports.someItem = someItem;
    exports.sortItems = sortItems;
    exports.startsWith = startsWith;
    exports.strictObject = strictObject;
    exports.strictObjectAsync = strictObjectAsync;
    exports.strictTuple = strictTuple;
    exports.strictTupleAsync = strictTupleAsync;
    exports.string = string;
    exports.stringifyJson = stringifyJson;
    exports.summarize = summarize;
    exports.symbol = symbol;
    exports.title = title;
    exports.toBigint = toBigint;
    exports.toBoolean = toBoolean;
    exports.toDate = toDate;
    exports.toLowerCase = toLowerCase;
    exports.toMaxValue = toMaxValue;
    exports.toMinValue = toMinValue;
    exports.toNumber = toNumber;
    exports.toString = toString2;
    exports.toUpperCase = toUpperCase;
    exports.transform = transform;
    exports.transformAsync = transformAsync;
    exports.trim = trim;
    exports.trimEnd = trimEnd;
    exports.trimStart = trimStart;
    exports.tuple = tuple;
    exports.tupleAsync = tupleAsync;
    exports.tupleWithRest = tupleWithRest;
    exports.tupleWithRestAsync = tupleWithRestAsync;
    exports.ulid = ulid;
    exports.undefined = undefined_;
    exports.undefined_ = undefined_;
    exports.undefinedable = undefinedable;
    exports.undefinedableAsync = undefinedableAsync;
    exports.union = union;
    exports.unionAsync = unionAsync;
    exports.unknown = unknown;
    exports.unwrap = unwrap;
    exports.url = url;
    exports.uuid = uuid;
    exports.value = value;
    exports.values = values;
    exports.variant = variant;
    exports.variantAsync = variantAsync;
    exports.void = void_;
    exports.void_ = void_;
    exports.words = words;
  }
});

// node_modules/lodash-es/isArray.js
var isArray, isArray_default;
var init_isArray = __esm({
  "node_modules/lodash-es/isArray.js"() {
    isArray = Array.isArray;
    isArray_default = isArray;
  }
});

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal, freeGlobal_default;
var init_freeGlobal = __esm({
  "node_modules/lodash-es/_freeGlobal.js"() {
    freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    freeGlobal_default = freeGlobal;
  }
});

// node_modules/lodash-es/_root.js
var freeSelf, root, root_default;
var init_root = __esm({
  "node_modules/lodash-es/_root.js"() {
    init_freeGlobal();
    freeSelf = typeof self == "object" && self && self.Object === Object && self;
    root = freeGlobal_default || freeSelf || Function("return this")();
    root_default = root;
  }
});

// node_modules/lodash-es/_Symbol.js
var Symbol, Symbol_default;
var init_Symbol = __esm({
  "node_modules/lodash-es/_Symbol.js"() {
    init_root();
    Symbol = root_default.Symbol;
    Symbol_default = Symbol;
  }
});

// node_modules/lodash-es/_getRawTag.js
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var objectProto, hasOwnProperty, nativeObjectToString, symToStringTag, getRawTag_default;
var init_getRawTag = __esm({
  "node_modules/lodash-es/_getRawTag.js"() {
    init_Symbol();
    objectProto = Object.prototype;
    hasOwnProperty = objectProto.hasOwnProperty;
    nativeObjectToString = objectProto.toString;
    symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
    getRawTag_default = getRawTag;
  }
});

// node_modules/lodash-es/_objectToString.js
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectProto2, nativeObjectToString2, objectToString_default;
var init_objectToString = __esm({
  "node_modules/lodash-es/_objectToString.js"() {
    objectProto2 = Object.prototype;
    nativeObjectToString2 = objectProto2.toString;
    objectToString_default = objectToString;
  }
});

// node_modules/lodash-es/_baseGetTag.js
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var nullTag, undefinedTag, symToStringTag2, baseGetTag_default;
var init_baseGetTag = __esm({
  "node_modules/lodash-es/_baseGetTag.js"() {
    init_Symbol();
    init_getRawTag();
    init_objectToString();
    nullTag = "[object Null]";
    undefinedTag = "[object Undefined]";
    symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
    baseGetTag_default = baseGetTag;
  }
});

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default;
var init_isObjectLike = __esm({
  "node_modules/lodash-es/isObjectLike.js"() {
    isObjectLike_default = isObjectLike;
  }
});

// node_modules/lodash-es/isSymbol.js
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var symbolTag, isSymbol_default;
var init_isSymbol = __esm({
  "node_modules/lodash-es/isSymbol.js"() {
    init_baseGetTag();
    init_isObjectLike();
    symbolTag = "[object Symbol]";
    isSymbol_default = isSymbol;
  }
});

// node_modules/lodash-es/_isKey.js
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var reIsDeepProp, reIsPlainProp, isKey_default;
var init_isKey = __esm({
  "node_modules/lodash-es/_isKey.js"() {
    init_isArray();
    init_isSymbol();
    reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    reIsPlainProp = /^\w*$/;
    isKey_default = isKey;
  }
});

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default;
var init_isObject = __esm({
  "node_modules/lodash-es/isObject.js"() {
    isObject_default = isObject;
  }
});

// node_modules/lodash-es/isFunction.js
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var asyncTag, funcTag, genTag, proxyTag, isFunction_default;
var init_isFunction = __esm({
  "node_modules/lodash-es/isFunction.js"() {
    init_baseGetTag();
    init_isObject();
    asyncTag = "[object AsyncFunction]";
    funcTag = "[object Function]";
    genTag = "[object GeneratorFunction]";
    proxyTag = "[object Proxy]";
    isFunction_default = isFunction;
  }
});

// node_modules/lodash-es/_coreJsData.js
var coreJsData, coreJsData_default;
var init_coreJsData = __esm({
  "node_modules/lodash-es/_coreJsData.js"() {
    init_root();
    coreJsData = root_default["__core-js_shared__"];
    coreJsData_default = coreJsData;
  }
});

// node_modules/lodash-es/_isMasked.js
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var maskSrcKey, isMasked_default;
var init_isMasked = __esm({
  "node_modules/lodash-es/_isMasked.js"() {
    init_coreJsData();
    maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    })();
    isMasked_default = isMasked;
  }
});

// node_modules/lodash-es/_toSource.js
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var funcProto, funcToString, toSource_default;
var init_toSource = __esm({
  "node_modules/lodash-es/_toSource.js"() {
    funcProto = Function.prototype;
    funcToString = funcProto.toString;
    toSource_default = toSource;
  }
});

// node_modules/lodash-es/_baseIsNative.js
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var reRegExpChar, reIsHostCtor, funcProto2, objectProto3, funcToString2, hasOwnProperty2, reIsNative, baseIsNative_default;
var init_baseIsNative = __esm({
  "node_modules/lodash-es/_baseIsNative.js"() {
    init_isFunction();
    init_isMasked();
    init_isObject();
    init_toSource();
    reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    reIsHostCtor = /^\[object .+?Constructor\]$/;
    funcProto2 = Function.prototype;
    objectProto3 = Object.prototype;
    funcToString2 = funcProto2.toString;
    hasOwnProperty2 = objectProto3.hasOwnProperty;
    reIsNative = RegExp(
      "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    baseIsNative_default = baseIsNative;
  }
});

// node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default;
var init_getValue = __esm({
  "node_modules/lodash-es/_getValue.js"() {
    getValue_default = getValue;
  }
});

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default;
var init_getNative = __esm({
  "node_modules/lodash-es/_getNative.js"() {
    init_baseIsNative();
    init_getValue();
    getNative_default = getNative;
  }
});

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate, nativeCreate_default;
var init_nativeCreate = __esm({
  "node_modules/lodash-es/_nativeCreate.js"() {
    init_getNative();
    nativeCreate = getNative_default(Object, "create");
    nativeCreate_default = nativeCreate;
  }
});

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default;
var init_hashClear = __esm({
  "node_modules/lodash-es/_hashClear.js"() {
    init_nativeCreate();
    hashClear_default = hashClear;
  }
});

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default;
var init_hashDelete = __esm({
  "node_modules/lodash-es/_hashDelete.js"() {
    hashDelete_default = hashDelete;
  }
});

// node_modules/lodash-es/_hashGet.js
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty3.call(data, key) ? data[key] : void 0;
}
var HASH_UNDEFINED, objectProto4, hasOwnProperty3, hashGet_default;
var init_hashGet = __esm({
  "node_modules/lodash-es/_hashGet.js"() {
    init_nativeCreate();
    HASH_UNDEFINED = "__lodash_hash_undefined__";
    objectProto4 = Object.prototype;
    hasOwnProperty3 = objectProto4.hasOwnProperty;
    hashGet_default = hashGet;
  }
});

// node_modules/lodash-es/_hashHas.js
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);
}
var objectProto5, hasOwnProperty4, hashHas_default;
var init_hashHas = __esm({
  "node_modules/lodash-es/_hashHas.js"() {
    init_nativeCreate();
    objectProto5 = Object.prototype;
    hasOwnProperty4 = objectProto5.hasOwnProperty;
    hashHas_default = hashHas;
  }
});

// node_modules/lodash-es/_hashSet.js
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var HASH_UNDEFINED2, hashSet_default;
var init_hashSet = __esm({
  "node_modules/lodash-es/_hashSet.js"() {
    init_nativeCreate();
    HASH_UNDEFINED2 = "__lodash_hash_undefined__";
    hashSet_default = hashSet;
  }
});

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
var Hash_default;
var init_Hash = __esm({
  "node_modules/lodash-es/_Hash.js"() {
    init_hashClear();
    init_hashDelete();
    init_hashGet();
    init_hashHas();
    init_hashSet();
    Hash.prototype.clear = hashClear_default;
    Hash.prototype["delete"] = hashDelete_default;
    Hash.prototype.get = hashGet_default;
    Hash.prototype.has = hashHas_default;
    Hash.prototype.set = hashSet_default;
    Hash_default = Hash;
  }
});

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default;
var init_listCacheClear = __esm({
  "node_modules/lodash-es/_listCacheClear.js"() {
    listCacheClear_default = listCacheClear;
  }
});

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default;
var init_eq = __esm({
  "node_modules/lodash-es/eq.js"() {
    eq_default = eq;
  }
});

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default;
var init_assocIndexOf = __esm({
  "node_modules/lodash-es/_assocIndexOf.js"() {
    init_eq();
    assocIndexOf_default = assocIndexOf;
  }
});

// node_modules/lodash-es/_listCacheDelete.js
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var arrayProto, splice, listCacheDelete_default;
var init_listCacheDelete = __esm({
  "node_modules/lodash-es/_listCacheDelete.js"() {
    init_assocIndexOf();
    arrayProto = Array.prototype;
    splice = arrayProto.splice;
    listCacheDelete_default = listCacheDelete;
  }
});

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default;
var init_listCacheGet = __esm({
  "node_modules/lodash-es/_listCacheGet.js"() {
    init_assocIndexOf();
    listCacheGet_default = listCacheGet;
  }
});

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default;
var init_listCacheHas = __esm({
  "node_modules/lodash-es/_listCacheHas.js"() {
    init_assocIndexOf();
    listCacheHas_default = listCacheHas;
  }
});

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default;
var init_listCacheSet = __esm({
  "node_modules/lodash-es/_listCacheSet.js"() {
    init_assocIndexOf();
    listCacheSet_default = listCacheSet;
  }
});

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
var ListCache_default;
var init_ListCache = __esm({
  "node_modules/lodash-es/_ListCache.js"() {
    init_listCacheClear();
    init_listCacheDelete();
    init_listCacheGet();
    init_listCacheHas();
    init_listCacheSet();
    ListCache.prototype.clear = listCacheClear_default;
    ListCache.prototype["delete"] = listCacheDelete_default;
    ListCache.prototype.get = listCacheGet_default;
    ListCache.prototype.has = listCacheHas_default;
    ListCache.prototype.set = listCacheSet_default;
    ListCache_default = ListCache;
  }
});

// node_modules/lodash-es/_Map.js
var Map2, Map_default;
var init_Map = __esm({
  "node_modules/lodash-es/_Map.js"() {
    init_getNative();
    init_root();
    Map2 = getNative_default(root_default, "Map");
    Map_default = Map2;
  }
});

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default;
var init_mapCacheClear = __esm({
  "node_modules/lodash-es/_mapCacheClear.js"() {
    init_Hash();
    init_ListCache();
    init_Map();
    mapCacheClear_default = mapCacheClear;
  }
});

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default;
var init_isKeyable = __esm({
  "node_modules/lodash-es/_isKeyable.js"() {
    isKeyable_default = isKeyable;
  }
});

// node_modules/lodash-es/_getMapData.js
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default;
var init_getMapData = __esm({
  "node_modules/lodash-es/_getMapData.js"() {
    init_isKeyable();
    getMapData_default = getMapData;
  }
});

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default;
var init_mapCacheDelete = __esm({
  "node_modules/lodash-es/_mapCacheDelete.js"() {
    init_getMapData();
    mapCacheDelete_default = mapCacheDelete;
  }
});

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default;
var init_mapCacheGet = __esm({
  "node_modules/lodash-es/_mapCacheGet.js"() {
    init_getMapData();
    mapCacheGet_default = mapCacheGet;
  }
});

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default;
var init_mapCacheHas = __esm({
  "node_modules/lodash-es/_mapCacheHas.js"() {
    init_getMapData();
    mapCacheHas_default = mapCacheHas;
  }
});

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default;
var init_mapCacheSet = __esm({
  "node_modules/lodash-es/_mapCacheSet.js"() {
    init_getMapData();
    mapCacheSet_default = mapCacheSet;
  }
});

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
var MapCache_default;
var init_MapCache = __esm({
  "node_modules/lodash-es/_MapCache.js"() {
    init_mapCacheClear();
    init_mapCacheDelete();
    init_mapCacheGet();
    init_mapCacheHas();
    init_mapCacheSet();
    MapCache.prototype.clear = mapCacheClear_default;
    MapCache.prototype["delete"] = mapCacheDelete_default;
    MapCache.prototype.get = mapCacheGet_default;
    MapCache.prototype.has = mapCacheHas_default;
    MapCache.prototype.set = mapCacheSet_default;
    MapCache_default = MapCache;
  }
});

// node_modules/lodash-es/memoize.js
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
var FUNC_ERROR_TEXT, memoize_default;
var init_memoize = __esm({
  "node_modules/lodash-es/memoize.js"() {
    init_MapCache();
    FUNC_ERROR_TEXT = "Expected a function";
    memoize.Cache = MapCache_default;
    memoize_default = memoize;
  }
});

// node_modules/lodash-es/_memoizeCapped.js
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var MAX_MEMOIZE_SIZE, memoizeCapped_default;
var init_memoizeCapped = __esm({
  "node_modules/lodash-es/_memoizeCapped.js"() {
    init_memoize();
    MAX_MEMOIZE_SIZE = 500;
    memoizeCapped_default = memoizeCapped;
  }
});

// node_modules/lodash-es/_stringToPath.js
var rePropName, reEscapeChar, stringToPath, stringToPath_default;
var init_stringToPath = __esm({
  "node_modules/lodash-es/_stringToPath.js"() {
    init_memoizeCapped();
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    reEscapeChar = /\\(\\)?/g;
    stringToPath = memoizeCapped_default(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    stringToPath_default = stringToPath;
  }
});

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var arrayMap_default;
var init_arrayMap = __esm({
  "node_modules/lodash-es/_arrayMap.js"() {
    arrayMap_default = arrayMap;
  }
});

// node_modules/lodash-es/_baseToString.js
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var INFINITY, symbolProto, symbolToString, baseToString_default;
var init_baseToString = __esm({
  "node_modules/lodash-es/_baseToString.js"() {
    init_Symbol();
    init_arrayMap();
    init_isArray();
    init_isSymbol();
    INFINITY = 1 / 0;
    symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
    symbolToString = symbolProto ? symbolProto.toString : void 0;
    baseToString_default = baseToString;
  }
});

// node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default;
var init_toString = __esm({
  "node_modules/lodash-es/toString.js"() {
    init_baseToString();
    toString_default = toString;
  }
});

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default;
var init_castPath = __esm({
  "node_modules/lodash-es/_castPath.js"() {
    init_isArray();
    init_isKey();
    init_stringToPath();
    init_toString();
    castPath_default = castPath;
  }
});

// node_modules/lodash-es/_toKey.js
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
var INFINITY2, toKey_default;
var init_toKey = __esm({
  "node_modules/lodash-es/_toKey.js"() {
    init_isSymbol();
    INFINITY2 = 1 / 0;
    toKey_default = toKey;
  }
});

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var baseGet_default;
var init_baseGet = __esm({
  "node_modules/lodash-es/_baseGet.js"() {
    init_castPath();
    init_toKey();
    baseGet_default = baseGet;
  }
});

// node_modules/lodash-es/_defineProperty.js
var defineProperty, defineProperty_default;
var init_defineProperty = __esm({
  "node_modules/lodash-es/_defineProperty.js"() {
    init_getNative();
    defineProperty = (function() {
      try {
        var func = getNative_default(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    })();
    defineProperty_default = defineProperty;
  }
});

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default;
var init_baseAssignValue = __esm({
  "node_modules/lodash-es/_baseAssignValue.js"() {
    init_defineProperty();
    baseAssignValue_default = baseAssignValue;
  }
});

// node_modules/lodash-es/_assignValue.js
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty5.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var objectProto6, hasOwnProperty5, assignValue_default;
var init_assignValue = __esm({
  "node_modules/lodash-es/_assignValue.js"() {
    init_baseAssignValue();
    init_eq();
    objectProto6 = Object.prototype;
    hasOwnProperty5 = objectProto6.hasOwnProperty;
    assignValue_default = assignValue;
  }
});

// node_modules/lodash-es/_isIndex.js
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var MAX_SAFE_INTEGER, reIsUint, isIndex_default;
var init_isIndex = __esm({
  "node_modules/lodash-es/_isIndex.js"() {
    MAX_SAFE_INTEGER = 9007199254740991;
    reIsUint = /^(?:0|[1-9]\d*)$/;
    isIndex_default = isIndex;
  }
});

// node_modules/lodash-es/_baseSet.js
function baseSet(object, path, value, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path = castPath_default(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey_default(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var baseSet_default;
var init_baseSet = __esm({
  "node_modules/lodash-es/_baseSet.js"() {
    init_assignValue();
    init_castPath();
    init_isIndex();
    init_isObject();
    init_toKey();
    baseSet_default = baseSet;
  }
});

// node_modules/lodash-es/_basePickBy.js
function basePickBy(object, paths, predicate) {
  var index = -1, length = paths.length, result = {};
  while (++index < length) {
    var path = paths[index], value = baseGet_default(object, path);
    if (predicate(value, path)) {
      baseSet_default(result, castPath_default(path, object), value);
    }
  }
  return result;
}
var basePickBy_default;
var init_basePickBy = __esm({
  "node_modules/lodash-es/_basePickBy.js"() {
    init_baseGet();
    init_baseSet();
    init_castPath();
    basePickBy_default = basePickBy;
  }
});

// node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default;
var init_baseHasIn = __esm({
  "node_modules/lodash-es/_baseHasIn.js"() {
    baseHasIn_default = baseHasIn;
  }
});

// node_modules/lodash-es/_baseIsArguments.js
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var argsTag, baseIsArguments_default;
var init_baseIsArguments = __esm({
  "node_modules/lodash-es/_baseIsArguments.js"() {
    init_baseGetTag();
    init_isObjectLike();
    argsTag = "[object Arguments]";
    baseIsArguments_default = baseIsArguments;
  }
});

// node_modules/lodash-es/isArguments.js
var objectProto7, hasOwnProperty6, propertyIsEnumerable, isArguments, isArguments_default;
var init_isArguments = __esm({
  "node_modules/lodash-es/isArguments.js"() {
    init_baseIsArguments();
    init_isObjectLike();
    objectProto7 = Object.prototype;
    hasOwnProperty6 = objectProto7.hasOwnProperty;
    propertyIsEnumerable = objectProto7.propertyIsEnumerable;
    isArguments = baseIsArguments_default(/* @__PURE__ */ (function() {
      return arguments;
    })()) ? baseIsArguments_default : function(value) {
      return isObjectLike_default(value) && hasOwnProperty6.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    isArguments_default = isArguments;
  }
});

// node_modules/lodash-es/isLength.js
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var MAX_SAFE_INTEGER2, isLength_default;
var init_isLength = __esm({
  "node_modules/lodash-es/isLength.js"() {
    MAX_SAFE_INTEGER2 = 9007199254740991;
    isLength_default = isLength;
  }
});

// node_modules/lodash-es/_hasPath.js
function hasPath(object, path, hasFunc) {
  path = castPath_default(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey_default(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default;
var init_hasPath = __esm({
  "node_modules/lodash-es/_hasPath.js"() {
    init_castPath();
    init_isArguments();
    init_isArray();
    init_isIndex();
    init_isLength();
    init_toKey();
    hasPath_default = hasPath;
  }
});

// node_modules/lodash-es/hasIn.js
function hasIn(object, path) {
  return object != null && hasPath_default(object, path, baseHasIn_default);
}
var hasIn_default;
var init_hasIn = __esm({
  "node_modules/lodash-es/hasIn.js"() {
    init_baseHasIn();
    init_hasPath();
    hasIn_default = hasIn;
  }
});

// node_modules/lodash-es/_basePick.js
function basePick(object, paths) {
  return basePickBy_default(object, paths, function(value, path) {
    return hasIn_default(object, path);
  });
}
var basePick_default;
var init_basePick = __esm({
  "node_modules/lodash-es/_basePick.js"() {
    init_basePickBy();
    init_hasIn();
    basePick_default = basePick;
  }
});

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var arrayPush_default;
var init_arrayPush = __esm({
  "node_modules/lodash-es/_arrayPush.js"() {
    arrayPush_default = arrayPush;
  }
});

// node_modules/lodash-es/_isFlattenable.js
function isFlattenable(value) {
  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var spreadableSymbol, isFlattenable_default;
var init_isFlattenable = __esm({
  "node_modules/lodash-es/_isFlattenable.js"() {
    init_Symbol();
    init_isArguments();
    init_isArray();
    spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
    isFlattenable_default = isFlattenable;
  }
});

// node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1, length = array.length;
  predicate || (predicate = isFlattenable_default);
  result || (result = []);
  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush_default(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var baseFlatten_default;
var init_baseFlatten = __esm({
  "node_modules/lodash-es/_baseFlatten.js"() {
    init_arrayPush();
    init_isFlattenable();
    baseFlatten_default = baseFlatten;
  }
});

// node_modules/lodash-es/flatten.js
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten_default(array, 1) : [];
}
var flatten_default;
var init_flatten = __esm({
  "node_modules/lodash-es/flatten.js"() {
    init_baseFlatten();
    flatten_default = flatten;
  }
});

// node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default;
var init_apply = __esm({
  "node_modules/lodash-es/_apply.js"() {
    apply_default = apply;
  }
});

// node_modules/lodash-es/_overRest.js
function overRest(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply_default(func, this, otherArgs);
  };
}
var nativeMax, overRest_default;
var init_overRest = __esm({
  "node_modules/lodash-es/_overRest.js"() {
    init_apply();
    nativeMax = Math.max;
    overRest_default = overRest;
  }
});

// node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default;
var init_constant = __esm({
  "node_modules/lodash-es/constant.js"() {
    constant_default = constant;
  }
});

// node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default;
var init_identity = __esm({
  "node_modules/lodash-es/identity.js"() {
    identity_default = identity;
  }
});

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString, baseSetToString_default;
var init_baseSetToString = __esm({
  "node_modules/lodash-es/_baseSetToString.js"() {
    init_constant();
    init_defineProperty();
    init_identity();
    baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
      return defineProperty_default(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant_default(string),
        "writable": true
      });
    };
    baseSetToString_default = baseSetToString;
  }
});

// node_modules/lodash-es/_shortOut.js
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var HOT_COUNT, HOT_SPAN, nativeNow, shortOut_default;
var init_shortOut = __esm({
  "node_modules/lodash-es/_shortOut.js"() {
    HOT_COUNT = 800;
    HOT_SPAN = 16;
    nativeNow = Date.now;
    shortOut_default = shortOut;
  }
});

// node_modules/lodash-es/_setToString.js
var setToString, setToString_default;
var init_setToString = __esm({
  "node_modules/lodash-es/_setToString.js"() {
    init_baseSetToString();
    init_shortOut();
    setToString = shortOut_default(baseSetToString_default);
    setToString_default = setToString;
  }
});

// node_modules/lodash-es/_flatRest.js
function flatRest(func) {
  return setToString_default(overRest_default(func, void 0, flatten_default), func + "");
}
var flatRest_default;
var init_flatRest = __esm({
  "node_modules/lodash-es/_flatRest.js"() {
    init_flatten();
    init_overRest();
    init_setToString();
    flatRest_default = flatRest;
  }
});

// node_modules/lodash-es/pick.js
var pick_exports = {};
__export(pick_exports, {
  default: () => pick_default
});
var pick, pick_default;
var init_pick = __esm({
  "node_modules/lodash-es/pick.js"() {
    init_basePick();
    init_flatRest();
    pick = flatRest_default(function(object, paths) {
      return object == null ? {} : basePick_default(object, paths);
    });
    pick_default = pick;
  }
});

// node_modules/@react-router/dev/dist/routes.js
var require_routes = __commonJS({
  "node_modules/@react-router/dev/dist/routes.js"(exports, module) {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var routes_exports = {};
    __export2(routes_exports, {
      getAppDirectory: () => getAppDirectory,
      index: () => index,
      layout: () => layout,
      prefix: () => prefix,
      relative: () => relative2,
      route: () => route
    });
    module.exports = __toCommonJS2(routes_exports);
    var Path = __toESM(require_dist());
    var v = __toESM(require_dist2());
    var import_pick = __toESM((init_pick(), __toCommonJS(pick_exports)));
    function invariant(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        console.error(
          "The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose"
        );
        throw new Error(message);
      }
    }
    function getAppDirectory() {
      invariant(globalThis.__reactRouterAppDirectory);
      return globalThis.__reactRouterAppDirectory;
    }
    var routeConfigEntrySchema = v.pipe(
      v.custom((value) => {
        return !(typeof value === "object" && value !== null && "then" in value && "catch" in value);
      }, "Invalid type: Expected object but received a promise. Did you forget to await?"),
      v.object({
        id: v.optional(
          v.pipe(
            v.string(),
            v.notValue("root", "A route cannot use the reserved id 'root'.")
          )
        ),
        path: v.optional(v.string()),
        index: v.optional(v.boolean()),
        caseSensitive: v.optional(v.boolean()),
        file: v.string(),
        children: v.optional(v.array(v.lazy(() => routeConfigEntrySchema)))
      })
    );
    var resolvedRouteConfigSchema = v.array(routeConfigEntrySchema);
    var createConfigRouteOptionKeys = [
      "id",
      "index",
      "caseSensitive"
    ];
    function route(path, file, optionsOrChildren, children) {
      let options = {};
      if (Array.isArray(optionsOrChildren) || !optionsOrChildren) {
        children = optionsOrChildren;
      } else {
        options = optionsOrChildren;
      }
      return {
        file,
        children,
        path: path ?? void 0,
        ...(0, import_pick.default)(options, createConfigRouteOptionKeys)
      };
    }
    var createIndexOptionKeys = ["id"];
    function index(file, options) {
      return {
        file,
        index: true,
        ...(0, import_pick.default)(options, createIndexOptionKeys)
      };
    }
    var createLayoutOptionKeys = ["id"];
    function layout(file, optionsOrChildren, children) {
      let options = {};
      if (Array.isArray(optionsOrChildren) || !optionsOrChildren) {
        children = optionsOrChildren;
      } else {
        options = optionsOrChildren;
      }
      return {
        file,
        children,
        ...(0, import_pick.default)(options, createLayoutOptionKeys)
      };
    }
    function prefix(prefixPath, routes) {
      return routes.map((route2) => {
        if (route2.index || typeof route2.path === "string") {
          return {
            ...route2,
            path: route2.path ? joinRoutePaths(prefixPath, route2.path) : prefixPath,
            children: route2.children
          };
        } else if (route2.children) {
          return {
            ...route2,
            children: prefix(prefixPath, route2.children)
          };
        }
        return route2;
      });
    }
    function relative2(directory) {
      return {
        /**
         * Helper function for creating a route config entry, for use within
         * `routes.ts`. Note that this helper has been scoped, meaning that file
         * path will be resolved relative to the directory provided to the
         * `relative` call that created this helper.
         */
        route: (path, file, ...rest) => {
          return route(path, Path.resolve(directory, file), ...rest);
        },
        /**
         * Helper function for creating a route config entry for an index route, for
         * use within `routes.ts`. Note that this helper has been scoped, meaning
         * that file path will be resolved relative to the directory provided to the
         * `relative` call that created this helper.
         */
        index: (file, ...rest) => {
          return index(Path.resolve(directory, file), ...rest);
        },
        /**
         * Helper function for creating a route config entry for a layout route, for
         * use within `routes.ts`. Note that this helper has been scoped, meaning
         * that file path will be resolved relative to the directory provided to the
         * `relative` call that created this helper.
         */
        layout: (file, ...rest) => {
          return layout(Path.resolve(directory, file), ...rest);
        },
        // Passthrough of helper functions that don't need relative scoping so that
        // a complete API is still provided.
        prefix
      };
    }
    function joinRoutePaths(path1, path2) {
      return [
        path1.replace(/\/+$/, ""),
        // Remove trailing slashes
        path2.replace(/^\/+/, "")
        // Remove leading slashes
      ].join("/");
    }
  }
});
export default require_routes();
/*! Bundled license information:

@react-router/dev/dist/routes.js:
  (**
   * @react-router/dev v7.13.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
*/
//# sourceMappingURL=@react-router_dev_routes.js.map
